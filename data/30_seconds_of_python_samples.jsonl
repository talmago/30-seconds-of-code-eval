{"task_id":"task/1","completion":"\n\n\" Return index of value in list, -1 if not present \"\n\nfor i in range ( len (lst)):\n\nif lst[i] == value:\n\nreturn i\n\nreturn - 1\n\ndef index_of_one(lst, value):\n\n\" Return index of value"}
{"task_id":"task/1","completion":" \"\"\"Returns index of all items that matches value\"\"\" return max(len(lst) for lst in lst if lst.index(value) != -1)\n\nThe index_of_all function will take a list and return the index of the first item that matches the value. In other words, it\u2019s"}
{"task_id":"task/1","completion":"\n\n#print lst\n\nfor value in lst:\n\nif value == value:\n\nreturn index\n\nreturn -1\n\nindex = index_of_all(lst, value)\n\nif index != -1:\n\nreturn index\n\nreturn -1\n\ndef count_all(l"}
{"task_id":"task/1","completion":"\n\nfor i in range(len(lst)):\n\nif lst[i] == value:\n\nreturn i\n\nreturn -1\n\n\ndef remove_all(lst, value):\n\nif index_of_all(lst, value) != -1:\n\nlst.remove("}
{"task_id":"task/1","completion":"\n\nwhile lst and lst[0] != value:\n\nlst = lst[1:]\n\nreturn lst.index(value)\n\n\ndef index_of_first(lst, value):\n\nwhile lst and lst[0] != value:\n\nlst = lst["}
{"task_id":"task/2","completion":" return lst[0]\n\n\u25b6 tuple\n\n>>> lst = [head(head(head(head([1, 2, 3]))))] >>> lst [1, 2, 3]\n\n\u25b6 tuple\n\n>>> lst = [head(head(head(head([1, 2, 3]"}
{"task_id":"task/2","completion":"\n\nreturn lst[0]\n\nExample 3-6. More Functional: map()\n\n>>> def map(lst, func):\n\n... lst = list(lst)\n\n... return (func(x) for x in lst)\n\n...\n\n>>> map(['a', 'b"}
{"task_id":"task/2","completion":" return ''.join(lst)\n\nhead = lambda lst: \"\".join(lst)\n\nTranslating to C\n\nIf you're planning to create a C extension module, you will also need to translate\n\nyour function to C. Here's how to do that:\n\nFirst, you need to"}
{"task_id":"task/2","completion":"\n\nreturn(lst[0])\n\nreturn(head(a1))\n\nreturn(head(a2))\n\nreturn(head(a3))\n\nprint(head(a4))\n\nprint(head(a5))\n\nprint(head(a6))\n\nprint(head(a"}
{"task_id":"task/2","completion":"\n\nreturn lst[0]\n\n\ndef tail(lst):\n\nreturn lst[1:]\n\n\ndef append(lst, elem):\n\nreturn lst + [elem]\n\n\ndef main():\n\nlst = [1, 2, 3]\n\nprint(head(lst"}
{"task_id":"task/3","completion":"\n\n\"\"\"Return the n-th largest element of the list.\"\"\"\n\nif n < 0:\n\nraise ValueError('Cannot take n < 0')\n\nif n >= len(lst):\n\nraise ValueError('Cannot take n >= len(lst)')\n\nelif n == 1:"}
{"task_id":"task/3","completion":"\n\n\"\"\"\n\nReturns an iterator that returns the n-th value of the given iterator lst.\n\n\"\"\"\n\nreturn itertools.count(lst, n)\n\ndef find_max(lst):\n\n\"\"\"\n\nReturns the maximum value in the given list.\n\n\"\"\"\n\nmax_"}
{"task_id":"task/3","completion":"\n\nret = lst[0]\n\nif len(lst) > 0:\n\nfor i in range(n):\n\nret = max(ret, lst[i])\n\nreturn ret\n\nprint max_n([10, 20, 100, 200])\n\n>>> 200\n\n\u8f93"}
{"task_id":"task/3","completion":"\n\n\"\"\"\n\n\u6c42max\u90a3\u4e2a\u8303\u56f4\u5185\u7684n\u8fd8\u4e0d\u53ef\u80fd\u88ab\u81ea\u53d8\u91cfn\u589e\u957f\n\n\"\"\"\n\nfor i in range(n):\n\nif lst[i] > max("}
{"task_id":"task/3","completion":" return lst[0] if lst else max_n(lst, n + 1) def gcd(a, b): if a == 0: return b else: return gcd(b % a, a)\n\nThe trouble with manual control flow is that it\u2019s hard to follow. It\u2019s"}
{"task_id":"task/4","completion":"\n\n# date.today() is a naive way to create a date\n\n# with the current time. If you're doing this in\n\n# production code, you're probably doing it wrong\n\n# (but this is okay for demonstration purposes)\n\nreturn date.today().isoformat()\n\n\nif __name__ =="}
{"task_id":"task/4","completion":"\n\n# d is already a datetime\n\nreturn d.strftime('%Y-%m-%d')\n\ndef convert_iso_date(d):\n\n# d is a string, convert to datetime\n\nd = datetime.strptime(d, '%Y-%m-%"}
{"task_id":"task/4","completion":"\n\nreturn datetime.strptime(d, \"%Y-%m-%d\").date()\n\ndef to_iso_time(t):\n\nreturn datetime.strptime(t, \"%Y-%m-%d %H:%M:%S\").time()\n\nISO_D"}
{"task_id":"task/4","completion":"\n\n\"\"\"Convert datetime to date\"\"\"\n\nreturn d.strftime('%Y-%m-%d')\n\ndef to_iso_time(d):\n\n\"\"\"Convert datetime to time\"\"\"\n\nreturn d.strftime('%H:%M:%S')\n\n# set the"}
{"task_id":"task/4","completion":"\n\nreturn d.year + \"-\" + d.month + \"-\" + d.day\n\ndef to_iso_datetime(d):\n\nreturn d.isoformat()\n\ndef get_schedule(id, from_date=None, to_date=None, page=1):\n\nbase_"}
{"task_id":"task/5","completion":"\n\nnumbers = len(list) // 2\n\nreturn list[numbers]\n\n\n\nThis is much cleaner, easier to read, and easier to program. The program still works just as well as before, but looks better.\n\n\n\nOne possible problem with this solution is that it actually takes up more memory than the original"}
{"task_id":"task/5","completion":" if len(list) > 1: return sorted(list) # no further sorting required if len(list) == 1: return list[0] # the one and only element of the list else: return list[len(list) / 2] # the middle element of the list\n\nThis function is very similar to the built-"}
{"task_id":"task/5","completion":"\n\nreturn sum(list)/len(list)\n\n\ndef create_users():\n\nreturn users\n\n\ndef create_replies():\n\nreturn replies\n\n\ndef random_color():\n\ncolor = 'black'\n\nfor i in range(10):\n\ncolor = '#%02x%02x%"}
{"task_id":"task/5","completion":"\n\nprint(list[len(list) / 2])\n\nprint(\"\n\n\")\n\nprint(median([10,20,30,40,50,60,70,80,90,100]))\n\nprint(\"\n\n\")\n\nelse:\n\nprint(\"All values in the list must be"}
{"task_id":"task/5","completion":" \"\"\" Find the median of a list. Return the list of sorted elements, the middle value, and the index of the middle value. >>> list = [-16, -5, -2, 3, -1, -1, 0, 0, 1, 1, 2, 5, 16] >>> sorted(list) [-16, -"}
{"task_id":"task/6","completion":" return max(args, key=args.get)\n\nThis can be tested with both explicit and implicit variadic arguments:\n\n>>> longest_item(*['bla', 'bla', 'bla']) 'bla' >>> longest_item('bla', 'bla', 'bla') 'bla'"}
{"task_id":"task/6","completion":"\n\nreturn max(args, key=itemgetter(1))\n\ndef is_id_in_set(set_, i):\n\nreturn set_.issubset(i)\n\ndef print_dict(dict, indent=4):\n\nprint('{}'.format(indent*' '*"}
{"task_id":"task/6","completion":" return args[0].value def longest_item_from_args(a): if len(a) >= 2: b = a[1] return longest_item(a[:2]) + longest_item(b) else: return a[0].value\n\nIf we want to chain multiple functions together, we can use"}
{"task_id":"task/6","completion":"\n\nreturn max(map(len, args))\n\nAnd with that, we have a working longest_item function.\n\nThe general case\n\nThe general case is quite similar. To implement the general case, we just need to consider the base case first.\n\n# general case\n\nif len(args) == 1"}
{"task_id":"task/6","completion":" return max(args, key=len)\n\nNow we get a TypeError: cannot compare 'int' with 'str' for <= .\n\nThis is a pretty heavy-handed way to fix the problem. The right way is to use a private variable (a.k.a. a local variable), like this:\n\n"}
{"task_id":"task/7","completion":"\n\n''' Returns a new iterable which generates the powerset of the input iterable.\n\nThe powerset of a set is the set of all subsets. E.g. powerset([1,2,3])\n\ngenerates [[], [1], [2], [1, 2], [3], ["}
{"task_id":"task/7","completion":"\n\nif iterable == set():\n\nreturn [[], []]\n\nnew_iter = iter(iterable)\n\nnew_iter.next()\n\nprev_iter = iter(iterable)\n\nwhile new_iter:\n\ncurrent_iter = new_iter\n\nif prev_iter:\n\n"}
{"task_id":"task/7","completion":"\n\npowerset = [[]]\n\nfor x in iterable:\n\npowerset.append(combinations(x, 2))\n\nreturn chain(powerset, [(list(set(powerset)),)]*len(powerset))\n\npowerset([1,2,3])\n\nfor x in powerset"}
{"task_id":"task/7","completion":"\n\n'''\n\nReturn the powerset of a set of elements\n\n'''\n\npowerset = set()\n\nfor element in iterable:\n\npowerset.add(element)\n\n# find all combinations\n\ncombinations = chain(itertools.product(*powerset), powerset)\n\n"}
{"task_id":"task/7","completion":"\n\n\"\"\"Return the powerset of an iterable.\"\"\"\n\npowerset = set()\n\nfor item in iterable:\n\npowerset = chain(powerset, combinations(item, 2))\n\nreturn powerset\n\n\n>>> powerset([1, 2, 3])\n\nset([1, 2, 3"}
{"task_id":"task/8","completion":"\n\nfor i in range(len(lst)):\n\nif fn(lst[i]):\n\nreturn i\n\nreturn -1\n\n\ndef find_index_of_first(lst, fn):\n\nfor i in range(len(lst)):\n\nif fn(lst["}
{"task_id":"task/8","completion":"\n\n# return None if no match was found\n\nif lst == []:\n\nreturn None\n\n# if the filter returns a true value, then the element is a match\n\nreturn find_index_of_all(fn(lst[0]), fn, lst[1:])\n\n\ndef find_"}
{"task_id":"task/8","completion":"\n\nindex = 0\n\nfor x in lst:\n\nif fn(x):\n\nindex += 1\n\nreturn index\n\nlst = [1,2,3,4,5,6,7,8,9,10]\n\nif lst == [1,2,3,4,"}
{"task_id":"task/8","completion":"\n\nn = len(lst)\n\nfor i in range(n):\n\nif fn(lst[i]):\n\nreturn i\n\nreturn -1\n\n\ndef find_max_of_all(lst, fn):\n\nn = len(lst)\n\nfor i in range("}
{"task_id":"task/8","completion":"\n\n# 1. \u5c06\u6570\u7ec4\u5206\u5272\u6210\u4e00\u4e2a\u4e2a\u6570\u7ec4\uff0c\u7136\u540e\u67e5\u627e\u6bcf\u4e2a\u6570\u7ec4\u4e2d\u662f\u5426\u6709fn\u8fd4\u56deTrue\uff0c\u5982"}
{"task_id":"task/9","completion":" pass\n\nHere's a function that takes a list, and prints out the values of each element, doubling the value of each number it encounters.\n\n>>> def double_each(my_list): ... for x in my_list: ... print x, ... >>> double_each([3, 2, 8, 5, 6,"}
{"task_id":"task/9","completion":"\n\nprint('take(%d)' % n)\n\nfor i in itr:\n\nprint(i)\n\nif __name__ == '__main__':\n\ntake(itr)\n\nrun | edit | history | help 0"}
{"task_id":"task/9","completion":" def take(n=1): \"\"\" Given an iterator, return an iterator that returns every nth item. \"\"\" for i in itr: if i < n: yield i itr = take(1) def take(n=1): \"\"\" Given an iterator, return an iterator that returns every nth item. \"\"\" for i in it"}
{"task_id":"task/9","completion":"\n\nif itr >= len(self):\n\nraise StopIteration\n\nyield from self[itr]\n\nself[itr] = y\n\nitr += n\n\nyield from self[itr]\n\ndef __iter__(self):\n\nreturn self.take(1)\n"}
{"task_id":"task/9","completion":"\n\nreturn itr + n\n\ndef iter_range(n, start = 0, stop = 10):\n\nfor i in range(start, stop, n):\n\nprint i\n\nif __name__ == '__main__':\n\nitr = iter_range(2, 5)\n\ntake("}
{"task_id":"task/10","completion":"\n\n\"\"\"last(lst) -> last item in lst\"\"\"\n\nreturn lst[len(lst)-1]\n\n\ndef __init__(self, name):\n\nself.name = name\n\nself.items = []\n\ndef add(self, item):\n\nself.items.append("}
{"task_id":"task/10","completion":"\n\nprint(lst[0], lst[1], lst[2])\n\ndef sum_arr(arr):\n\nsum = 0\n\nfor i in arr:\n\nsum += i\n\nreturn sum\n\ndef demo(arr, num, sum):\n\nprint(sum_arr(arr),"}
{"task_id":"task/10","completion":"\n\nprint lst\n\nif __name__ == '__main__':\n\nmain()\n\nAnd here is the output:\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n[1, 2, 3, 4, 5, 6, 7, 8"}
{"task_id":"task/10","completion":"\n\nif len(lst) > 0:\n\nreturn lst[-1]\n\nreturn None\n\n\ndef process(wanted):\n\n# print(wanted)\n\nfor n in range(1,101):\n\nif isPrime(n):\n\nif sieve[n] != 0:"}
{"task_id":"task/10","completion":"\n\nlst.append(None)\n\nprint(lst)\n\n5.5.2\n\nhttp://docs.python.org/tutorial/introduction.html\n\nhttp://docs.python.org/tutorial/introduction.html#lists\n\nhttp://docs.python.org/t"}
{"task_id":"task/11","completion":"\n\nnow = int(time.time())\n\nsleep(ms/1000.0)\n\nfn(*args)\n\nsleep(ms)\n\nprint(now - now % 1000)\n\ndelay(print, 1, 2, 3)\n\nsleep(1)\n\ndelay(print, 1, 2,"}
{"task_id":"task/11","completion":"\n\nsleep(ms)\n\nfn(*args)\n\ndelay(\u201cprint \u2018done\u2019\u201d, 100)\n\ndelay(\u201csleep\u201d, 100)\n\ndelay(\u201cprint \u2018done\u2019\u201d, 100)\n\ndelay(\u201csleep\u201d, 100)"}
{"task_id":"task/11","completion":"\n\nsleep(ms)\n\nfn(*args)\n\ndef execute_everything(fn, *args):\n\n\"Execute a function and wait for it to finish.\"\n\nfn(*args)\n\nsleep(0.5)\n\nfn(*args)\n\ndef execute_nothing(fn, *args):"}
{"task_id":"task/11","completion":"\n\nret = lambda : sleep(ms)\n\nret(*args)\n\nreturn ret\n\ndef sleep(ms):\n\ntime.sleep(ms)\n\ndef main():\n\ntry:\n\ndef do_something(a, b):\n\nreturn a + b\n\ndef do_something_else("}
{"task_id":"task/11","completion":"\n\ntime.sleep(ms)\n\nfn(*args)\n\ndelay(print, \"Hello world!\")\n\nprint \"Waiting...\"\n\nsleep(1000)\n\nprint \"Done!\"\n\nThe example above would print \"Hello world!\" and then wait for 1 second before exiting.\n\nimport time\n\n"}
{"task_id":"task/12","completion":"\n\nif len(args) == 1:\n\n# if there is only one argument, return a function that\n\n# takes the rest of the arguments.\n\nfn = partial(fn, *args[1:])\n\nreturn fn\n\ndef uncurry(fn, *args):\n\nif len(args)"}
{"task_id":"task/12","completion":"\n\n\"\"\"Curry a function from positional args to keyword args.\n\nArgs:\n\nfn: function to curry.\n\n*args: positional arguments to be curried.\n\nReturns:\n\nA new function that will call fn with positional arguments.\n\n\"\"\"\n\ndef _curry(*args, **kwargs"}
{"task_id":"task/12","completion":"\n\n\"\"\"\n\nCurry a function.\n\n*args can be a single iterable, or a sequence of individual arguments.\n\n@type fn: callable\n\n@param fn: function to curry\n\n@type args: iterable of any type\n\n@param args: arguments to curry\n\n@rtype"}
{"task_id":"task/12","completion":"\n\n\"\"\" Return a curried version of the function.\n\nIf there are N arguments to the function, the returned function\n\nwill take N-1 arguments.\n\n\"\"\"\n\ndef wrapper(*args):\n\nfn(*args[1:])\n\nreturn partial(wrapper, args[0])\n\nreturn wrapper\n"}
{"task_id":"task/12","completion":"\n\ndef curried(*fargs, **fkwargs):\n\nreturn fn(*args, **fkwargs)\n\nreturn curried\n\n# one tuple of positional arguments,\n\n# another tuple of keyword arguments\n\ndef add(x, y, *, z):\n\nreturn x + y + z\n"}
{"task_id":"task/13","completion":"\n\nwhile lst:\n\nif fn(lst[0]):\n\nreturn lst[0]\n\nelse:\n\nlst.pop(0)\n\nreturn None\n\n\nlst = [1,2,3,4,5,6,7,8,9,10]\n\n"}
{"task_id":"task/13","completion":"\n\n\nif lst == []:\n\nreturn []\n\nelif fn(lst[0]):\n\nreturn find(lst[1:], fn)\n\nelse:\n\nreturn find(lst[1:], fn) + [lst[0]]\n\n\ndef permutations(lst):"}
{"task_id":"task/13","completion":"\n\nfor i in lst:\n\nif fn(i):\n\nreturn i\n\nreturn None\n\n\ndef find_if(lst, fn):\n\nfor i in lst:\n\nif fn(i):\n\nreturn i\n\nreturn None\n\n\ndef findall(lst, fn):\n"}
{"task_id":"task/13","completion":"\n\ndef iter(iterable):\n\nfor x in iterable:\n\nyield x\n\nreturn iter(lst)\n\nreturn iter(find(lst, fn))\n\n# An iterator that produces the same result as a function.\n\ndef find_equiv(fn):\n\ndef iter("}
{"task_id":"task/13","completion":"\n\n\"\"\"\n\nReturn the first element in lst for which fn(lst[0]) is true.\n\nRaises ValueError if no such element is found.\n\n\"\"\"\n\nfor i in range(len(lst)):\n\nif fn(lst[i]):\n\nreturn lst["}
{"task_id":"task/14","completion":" \"\"\" Capitalize every word in s. \"\"\" s = s.title() return (s.capitalize() + s.lower()) def get_first_word(s): \"\"\" Get the first word of s, assuming it is a sentence. \"\"\" s = s.title() return s.capitalize() def lower_case_split("}
{"task_id":"task/14","completion":"\n\n\"\"\"\n\nCapitalize the first letter of every word in the string.\n\n\"\"\"\n\nreturn s.capitalize()\n\n\ndef is_palindrome(s):\n\n\"\"\"\n\nReturn True if the string is a palindrome, False otherwise.\n\n\"\"\"\n\nif s == s[::-"}
{"task_id":"task/14","completion":"\n\nreturn s.capitalize()\n\n\n\nreturn capitalize_every_word\n\n\n\ndef chomp_words(s):\n\nreturn s.rstrip('\n\n')\n\n\n\nreturn chomp_words\n\n\n\ndef replace_all(s, old, new):\n\nreturn s.replace(old,"}
{"task_id":"task/14","completion":" '''camel-case every word in a string''' return s.capitalize() def to_num(s): '''convert string to a number''' try: return int(s) except ValueError: return 0 def is_even(n): '''returns True if the number is even, otherwise returns False"}
{"task_id":"task/14","completion":" \"\"\" >>> str(capitalize_every_word(\"The quick brown fox jumps over the lazy dog\")) 'The Quick Brown Fox Jumps Over The Lazy Dog' \"\"\" if \" \" in s: s = s.capitalize() + \" \" for c in s: if c.isalpha(): s = s.capitalize() +"}
{"task_id":"task/15","completion":"\n\nif n == 2:\n\nreturn True\n\nif n < 2:\n\nreturn False\n\nfor i in range(3, int(sqrt(n)) + 1, 2):\n\nif n % i == 0:\n\nreturn False\n\nreturn True\n\ndef main():\n\nfor i in"}
{"task_id":"task/15","completion":"\n\n'''Return True if n is prime, False otherwise.\n\nTakes a number n, and returns True if it is a prime number, and False\n\notherwise. The definition of prime is this: a number n is prime if the\n\nonly positive divisors of n are 1 and n.\n\n''"}
{"task_id":"task/15","completion":"\n\n\"\"\" Checks whether n is prime or not \"\"\"\n\nif n <= 1:\n\nreturn False\n\nfor d in range(2, int(sqrt(n)) + 1):\n\nif n % d == 0:\n\nreturn False\n\nreturn True\n\n\"\"\" Returns the square root of a number \"\"\"\n"}
{"task_id":"task/15","completion":"\n\nif n < 2:\n\nreturn False\n\nelse:\n\nfor i in range(2, n):\n\nif n % i == 0:\n\nreturn False\n\nreturn True\n\ndef test_primality(n):\n\n# Test primality by computing a prime factor\n\nfor x in range"}
{"task_id":"task/15","completion":"\n\nif n < 2:\n\nreturn False\n\nfor i in range(2, n):\n\nif n % i == 0:\n\nreturn False\n\nreturn True\n\nTESTS = [\n\n[2, 2],\n\n[3, 3],\n\n[7, 7],\n\n["}
{"task_id":"task/16","completion":" for each in values: if each not in lst: return False return True\n\n\nListing 6.9. A filter that uses includes_all to ensure that a list includes all of the given values\n\n\ndef filter_items(lst, values): if includes_all(lst, values): return lst else: return"}
{"task_id":"task/16","completion":" \"\"\"Return True if all values in values are contained in lst. \"\"\" for v in values: if v not in lst: return False return True\n\n\nIn Python, if the values collection has a size of 2 and the lst collection has a size of 3, the expression lst == values will be True only if lst contains"}
{"task_id":"task/16","completion":" for value in values: lst.append(value) return lst == values\n\n\u5b9e\u73b0\u4e86\uff0c\u8fd0\u884c\u7ed3\u679c\u5982\u4e0b\uff1a\n\n[1, 2, 3, 4, 5] includes_all(1, [1, 2,"}
{"task_id":"task/16","completion":"\n\n\"\"\"\n\nReturn True if all items in lst are also values.\n\n\"\"\"\n\nfor item in lst:\n\nif item not in values:\n\nreturn False\n\nreturn True\n\n\ndef execute(command):\n\n\"\"\"\n\nDisplay the output of the command\n\n\"\"\"\n\noutput = sub"}
{"task_id":"task/16","completion":" #check if all values are in the list for val in values: if val not in lst: return False return True\n\nWe can also write a function which finds the minimum of two values\n\ndef min(x, y): if x <= y: return x else: return y\n\nWe can also write a function which finds"}
{"task_id":"task/17","completion":"\n\nstart = d.weekday()\n\nif start >= 6:\n\nreturn True\n\nreturn False\n\nclass WeekendWorker(object):\n\ndef __init__(self, name, hourly_rate, paid_hours):\n\nself.name = name\n\nself.hourly_rate = hourly_"}
{"task_id":"task/17","completion":"\n\nday1 = d.isoweekday()\n\nday2 = d.isoweekday()\n\nreturn day1 != day2 and day1 < 5\n\n\nIt is worth pointing out that datetime objects now include a weekday() method, which returns a (0-based) index for the weekday (Monday"}
{"task_id":"task/17","completion":"\n\nd = d.replace(hour = 0, minute = 0, second = 0, microsecond = 0)\n\nreturn (d.weekday() == 0 or\n\nd.isoweekday() == 6 or\n\nd.isoweekday() == 0 or\n\nd.isoweekday()"}
{"task_id":"task/17","completion":"\n\nreturn d.day_of_week in [0, 6]\n\nprint is_weekend()\n\nprint is_weekend(datetime(2012, 10, 20))\n\nprint is_weekend(datetime(2012, 10, 21))\n\nprint is_weekend(datetime(2012"}
{"task_id":"task/17","completion":"\n\nif d.day != d.weekday():\n\nreturn False\n\nd += datetime(d.year, d.month, 1)\n\nreturn True\n\n# random number function\n\ndef random_number(low, high):\n\nreturn random.randint(low, high)\n\n# get"}
{"task_id":"task/18","completion":"\n\nnewlist = []\n\nfor item in arg:\n\nnewlist.append(item)\n\nreturn newlist\n\ndef print_all(arg):\n\nfor item in arg:\n\nprint item\n\nif __name__ == '__main__':\n\nif len(sys.argv) =="}
{"task_id":"task/18","completion":"\n\nreturn arg.split(' ')\n\n\ndef replace(arg):\n\nreturn arg.replace('x', '*')\n\n\ndef reverse(arg):\n\nreturn arg[::-1]\n\n\ndef add(arg1, arg2):\n\nreturn arg1 + arg2\n\n\ndef multiply(arg1"}
{"task_id":"task/18","completion":" '''Iterate over a sequence, return first value and remainder as separate tuples. e.g. >>> spread([1, 2, 3, 4, 5]) [(1,), (2, 3), (4, 5)] ''' return itertools.tee(itertools.islice(arg, 2))"}
{"task_id":"task/18","completion":" # Formats a list of objects into a single string def string(obj): # Returns a string representation of an object return str(obj) # This will be our \"current\" string to work with result = '' # Loop through the arguments for arg in argv: # Split the argument into a list of strings words = arg.split()"}
{"task_id":"task/18","completion":"\n\nreturn [arg]\n\ndef reduce(arg):\n\nreturn arg\n\ndef identity(arg):\n\nreturn arg\n\ndef getLambda(arg):\n\nreturn lambda: arg\n\nif __name__ == '__main__':\n\nt = 5\n\nf = lambda x: x**"}
{"task_id":"task/19","completion":"\n\na = int(n)\n\nif a < 0:\n\nreturn -int(n)\n\nreturn a\n\ndef reverse_numbers(nums):\n\nif len(nums) == 0:\n\nreturn nums\n\nres = []\n\nfor i in range(len(nums"}
{"task_id":"task/19","completion":"\n\n' -1 if n < 0, 0 if n == 0, else n '\n\nif n < 0 :\n\nreturn - n\n\nreturn n\n\nclass Slider(Widget):\n\ndef __init__(self, master, slider_width, slider_height, color, selected, value,\n\n"}
{"task_id":"task/19","completion":"\n\n\"\"\"\n\nReturns n, with the digits reversed.\n\n>>> reverse_number(123)\n\n321\n\n>>> reverse_number(987)\n\n786\n\n>>> reverse_number(0)\n\n0\n\n>>> reverse_number(0.0)\n\n0.0\n\n>>> reverse_"}
{"task_id":"task/19","completion":"\n\nreturn copysign(0,n)\n\ndef cube_root(n):\n\nif n < 0:\n\nraise ValueError\n\nn = reverse_number(n)\n\nn = n * (n * (n * 6 - 3) / 2)\n\nreturn n\n\ndef extract_"}
{"task_id":"task/19","completion":"\n\n\"\"\"Return a number with its digits reversed.\"\"\"\n\nif n < 0:\n\nreturn -copysign(n,1) * 2\n\nresult = []\n\nwhile n > 0:\n\ndiv, rem = divmod(n, 10)\n\nresult.append(rem)\n\nn ="}
{"task_id":"task/20","completion":"\n\nreturn [word for word in re.findall(pattern, s) if word.isalpha()]\n\ndef word_count(words, word_pattern):\n\ncount = {}\n\nfor word in words:\n\ncount[word] = count.get(word, 0) + 1\n\nreturn count"}
{"task_id":"task/20","completion":"\n\nif not pattern.search(s):\n\nreturn []\n\nreturn s.split(pattern)\n\n\ndef dir_path(path):\n\nwhile True:\n\nroot, dirs, files = os.path.split(path)\n\npath = os.path.join(root, dirs, files"}
{"task_id":"task/20","completion":"\n\n\"\"\"Split string into a list of words, using the given pattern\"\"\"\n\nif pattern == '':\n\npattern = re.compile(r'[a-zA-Z-]+')\n\nelse:\n\npattern = re.compile(pattern)\n\nresult = []\n\nfor word in pattern"}
{"task_id":"task/20","completion":"\n\npat = re.compile(pattern)\n\nreturn re.findall(pat, s)\n\n\ndef get_contents(url):\n\npage = urllib.urlopen(url)\n\npage = page.read()\n\nreturn page\n\n\ndef extract_bookmarks(page):\n\n"}
{"task_id":"task/20","completion":"\n\n'''\n\nReturn list of words in the given string.\n\n>>> words('This is a test of the emergency broadcast system.')\n\n['This', 'is', 'a', 'test', 'of', 'the', 'emergency', 'broadcast', 'system']\n\n>>> words('This is a"}
{"task_id":"task/21","completion":"\n\nres = []\n\nfor x in lst:\n\nif choice(range(0,len(lst)-1)) == 0:\n\nres.append(x)\n\nreturn res\n\ndef primes(n):\n\nres = []\n\nif n <= 1:\n\nreturn\n\nelse"}
{"task_id":"task/21","completion":"\n\nif len(lst) == 0:\n\nreturn []\n\nelse:\n\nx = choice(lst)\n\ny = sample(lst[1:])\n\nreturn [x, y]\n\ndef choose(lst, k):\n\nreturn sample(lst)[1]\n\n"}
{"task_id":"task/21","completion":"\n\nreturn choice(lst)\n\n#---------------------------------------------------------------------------\n\n#subnodes\n\n#---------------------------------------------------------------------------\n\ndef subnode(node, id):\n\nif node == \"root\":\n\nreturn \"root\"\n\nelif node == \"p1\":\n\nreturn \"p1\"\n\nelif node"}
{"task_id":"task/21","completion":"\n\n\"\"\"\n\nReturns a random element from a list.\n\n\"\"\"\n\nreturn choice(lst)\n\ndef shuffle(lst):\n\n\"\"\"\n\nRandomly permutes the elements of a list in place.\n\n\"\"\"\n\nfor i in range(len(lst)):\n\nj = choice"}
{"task_id":"task/21","completion":"\n\n# sample without replacement\n\nreturn choice(lst)\n\nprint(sample(range(10)))\n\n\nThe following is the output.\n\n\n2.\n\n\nN= 5\n\ndef sample(lst):\n\n# sample without replacement\n\nreturn choice(lst)\n\nprint(sample(range"}
{"task_id":"task/22","completion":"\n\n# The naive way\n\nreturn timedelta(days=n) - date.today()\n\n\ndays_ago(7) # -> Wed Apr 26 23:23:02 2011\n\ndays_ago(10) # -> Tue Apr 25 23:23:02 2011\n\ndays_ago(3) # -> Tue"}
{"task_id":"task/22","completion":"\n\nreturn timedelta(days=n) - datetime.now()\n\ndef days_from_date(date):\n\nreturn timedelta(days=date.days) - date.replace(year=date.year, month=date.month, day=date.day)\n\ndef is_overdue("}
{"task_id":"task/22","completion":"\n\n\"\"\"\n\nReturns the number of days since the beginning of the year\n\n\"\"\"\n\nif n <= 0:\n\nreturn timedelta(0)\n\nreturn timedelta(days=n) - timedelta(days=365)\n\ndef datetime_to_seconds(d):\n\n\"\"\"\n\nCon"}
{"task_id":"task/22","completion":"\n\nif n < 0:\n\nraise ValueError('n must be >= 0')\n\nreturn timedelta(days=n)\n\ndef days_in_month(year, month):\n\nreturn days_in_year(year) - month + 1\n\ndef days_in_year(year):\n\n"}
{"task_id":"task/22","completion":"\n\n\"Return the number of days ago. Inspired by http://stackoverflow.com/a/8827807/852829\"\n\ndays = timedelta(days=n)\n\nt = time.localtime()\n\nt += timedelta(days=days)\n\nt += timedelta(days="}
{"task_id":"task/23","completion":"\n\nif key in d:\n\nreturn True\n\nelse:\n\nreturn False\n\ndef find_key_value(d, key):\n\nif key in d:\n\nreturn d[key]\n\nelse:\n\nreturn None\n\ndef index_of_key(d, key):\n\nfor"}
{"task_id":"task/23","completion":"\n\nif not key in d:\n\nd[key] = []\n\nreturn d[key]\n\ndef compare_values(v1, v2):\n\n# sort by name\n\nvalues = dict(v1)\n\nvalues.sort(key=key_in_dict, reverse=True)\n"}
{"task_id":"task/23","completion":"\n\nif key in d:\n\nreturn d[key]\n\nreturn {}\n\ndef key_in_dict_deep(d, key):\n\nif key in d:\n\nreturn d[key]\n\nfor key, value in d.items():\n\nif key == key:\n\nreturn value\n"}
{"task_id":"task/23","completion":"\n\nreturn key in d\n\n# WRAPME: Why is this necessary?\n\n# If a user attempts to set a key in __all__, it will error out\n\n# with this message:\n\n# TypeError: '__all__' only supports str, int, float, complex, type,\n\n"}
{"task_id":"task/23","completion":"\n\n- if key in d:\n\n- value = d[key]\n\n- print '%s is %s' % (key, value)\n\n- else:\n\n- print '%s not found in %s' % (key, d)\n\n-\n\ndef key_not_in_"}
{"task_id":"task/24","completion":"\n\nif num == 0:\n\nreturn 1\n\nelse:\n\nreturn num * factorial(num-1)\n\n# Factorial function\n\n\nprint(factorial(5))\n\n\n\n# Factorial function with one iteration only\n\n# (note use of lambda)\n\ndef factorial_one("}
{"task_id":"task/24","completion":" if num == 0: return 1 return num * factorial(num-1)\n\nfunction factorial(num): if num == 0: return 1 return num * factorial(num-1)\n\ndef factorial(num): if num == 0: return 1 return num * factorial(num-1)\n\nfunction"}
{"task_id":"task/24","completion":" if num == 0: return 1 else: return num * factorial(num-1)\n\n\n\nnum\n\nfactorial(num)\n\nnum-1\n\nfactorial(num-1)\n\nfactorial(num)\n\nfactorial(num-1)\n\nfactorial(num)\n\nfact"}
{"task_id":"task/24","completion":"\n\nif num == 0:\n\nreturn 1\n\nelse:\n\nreturn num * factorial(num-1)\n\n#\u533f\u540d\u51fd\u6570\n\n#def add(num1,num2):\n\n# return num1 + num2\n\n#\u533f\u540d\u51fd\u6570"}
{"task_id":"task/24","completion":" return 1 if num == 0 else num * factorial(num-1) def factorial2(num): return (num-1) * factorial(num) if __name__ == '__main__': # examples ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9"}
{"task_id":"task/25","completion":"\n\n'''initialize list of list\n\n'''\n\nreturn [[0]]*(lst[0]+1)\n\ndef build_reverse(lst):\n\n'''build reversed list of list\n\n'''\n\nreturn [[]]*(lst[0]+1)\n\ndef nth"}
{"task_id":"task/25","completion":"\n\nif lst:\n\nreturn [lst[0]]\n\nelse:\n\nreturn []\n\ndef append(lst, elem):\n\nif lst == []:\n\nreturn [elem]\n\nelse:\n\nreturn [lst[0], elem]\n\ndef combine("}
{"task_id":"task/25","completion":"\n\nprint(\"initial:\",lst)\n\nreturn lst\n\n\n\ndef print_list(lst):\n\nprint(\"print_list:\",lst)\n\nreturn lst\n\n\n\ndef add_list(lst, lst2):\n\nprint(\"add_list:\",lst,\""}
{"task_id":"task/25","completion":" print(\"Enter the name of the game : \") name = input() def GameOver(): print(\"Game Over\") def PlayAgain(): input(\"Play Again? (y/n)\") def start(): print(\"Welcome to the game.\n\nHere are the rules.\n\n\") print(\"1. Enter a number (1-5"}
{"task_id":"task/25","completion":"\n\nif len(lst) == 0:\n\nreturn lst\n\nres = []\n\nfor e in lst:\n\nres.append(e)\n\nreturn res\n\n\ndef length(lst):\n\nres = 0\n\nfor e in lst:\n\nres += 1\n\nreturn"}
{"task_id":"task/26","completion":"\n\nwhile len(s) < length:\n\ns = char + s\n\nreturn s\n\ndef all_twos(iterable):\n\n\"\"\"Returns an iterator of ones and twos.\"\"\"\n\nfor i in iterable:\n\nif i % 2 == 0:\n\nyield i\n\nel"}
{"task_id":"task/26","completion":"\n\n\"\"\"Pads a string with the specified character on the left\n\nuntil the string reaches the specified length.\"\"\"\n\nif length < len(s):\n\nreturn s\n\nelse:\n\nreturn s + char * (length - len(s))\n\ndef str_extend(s, length, char ="}
{"task_id":"task/26","completion":"\n\n\"\"\"Strips leading and trailing characters from a string, and\n\nreturns a new string where each character has been padded\n\nwith the specified character.\"\"\"\n\nreturn ''.join( [ pad( x, length, char ) for x in s ] )\n\n\n\n# #############################################################################\n\n#"}
{"task_id":"task/26","completion":"\n\n'''Add a character to the left of the string until it is at least `length` characters long.'''\n\nreturn s + char * (length - len(s))\n\ndef parse(s):\n\n'''Parse a string containing an integer, a decimal point, and a fractional part.'''\n"}
{"task_id":"task/26","completion":"\n\n\"\"\"Return a string of length length, with char padding out to\n\nthe left.\"\"\"\n\nreturn (s + char * (length - len(s))) % (length + 1)\n\ndef t_main():\n\n\"\"\"The main function.\"\"\"\n\nif len(sys.argv) != 2:"}
{"task_id":"task/27","completion":"\n\nreturn (deg * pi / 180)\n\ndef rads_to_degrees(rads):\n\nreturn (rads * 180 / pi)\n\ndef draw_quad_from_center(quad_from_center, center, radius, delta,\n\nquad_order, x, y, color):"}
{"task_id":"task/27","completion":"\n\nreturn deg * pi / 180\n\ndef rads_to_degrees(rads):\n\nreturn rads * 180 / pi\n\n# Main program logic goes here\n\n# create the rocket\n\nrocket = Rocket()\n\n# now add some details to the rocket\n\nrocket.name = \u201cR"}
{"task_id":"task/27","completion":"\n\nreturn deg * pi / 180.0\n\ndef rads_to_degrees(rads):\n\nreturn rads * 180.0 / pi\n\ndef print_angles(side1, side2, angle):\n\nangle = rads_to_degrees(angle)\n\nprint \"Angle"}
{"task_id":"task/27","completion":"\n\nreturn deg * pi / 180.0\n\ndef rads_to_degrees(rads):\n\nreturn rads * 180.0 / pi\n\n###\n\ndef main():\n\n# make sure we're using the right port.\n\nif len(sys.argv) != 2:\n\n"}
{"task_id":"task/27","completion":"\n\nreturn deg * pi / 180.0\n\ndef rads_to_degrees(rads):\n\nreturn rads * 180.0 / pi\n\nRADIANS = 0.0\n\nDEGREES = 0.0\n\nprint \"The following are the current values of the variables.\"\n"}
{"task_id":"task/28","completion":"\n\ndef _truncate(x, y):\n\ndef _square(x):\n\ndef _double(x):\n\ndef _add(x, y):\n\ndef _sub(x, y):\n\ndef _mul(x, y):\n\ndef _div(x, y):\n"}
{"task_id":"task/28","completion":"\n\nReduce the list of numbers to their lowest common multiple. The algorithm is based on the following identity (obtained by the Euclidean algorithm):\n\nwhere formula_2 denotes the greatest common divisor of the non-zero elements of formula_3.\n\nIn Python, the result of gcd(a, b"}
{"task_id":"task/28","completion":"\n\nif gcd(numbers[0], numbers[1]) != 1:\n\nnumbers[0] /= numbers[1]\n\nreturn reduce(lambda x, y: x * y, numbers) / reduce(lambda x, y: x * y, numbers)\n\ndef my_init():\n\n"}
{"task_id":"task/28","completion":"\nprint(gcd(a, b) * b / gcd(a, b) * a)\n\nlcm(['a', 'b', 'c'])\nlcm([1, 2, 3])\nlcm(['ab', 'cd'])\nlcm([1, 2, 3, 4"}
{"task_id":"task/28","completion":"\n\ndef _compute_lcm(list):\ndef _lcm(list):\n\ndef _sigma(x, y):\n\ndef _mul_inv(mul, inv):\n\ndef _primes_below(n):\n\ndef _twin_primes(n):\n\n"}
{"task_id":"task/29","completion":" \"\"\"Returns a list of the most frequent entries in lst.\"\"\" # Your code here. # Important point: on line 6, the input list lst is bound to the # variable lst_copy, which is used inside the for loop. # This avoids that each entry in lst is copied a number of times. return lst"}
{"task_id":"task/29","completion":"\n\ndef wrapper(item):\n\n# the next two lines convert the list into a set, then\n\n# back into a list again\n\nlst = set(lst)\n\nreturn item in lst\n\nreturn lambda x: max(len(x) for x in lst if wrapper(x))\n\n"}
{"task_id":"task/29","completion":"\n\n\"\"\"Determine the most frequent element in a list.\"\"\"\n\nmf = [0]*len(lst)\n\nfor i in range(len(lst)):\n\nmf[lst[i]] = mf[lst[i]] + 1\n\ncount = 0\n\n"}
{"task_id":"task/29","completion":"\n\ntotal = 0\n\ncounter = 0\n\nfor elem in lst:\n\ntotal += elem\n\ncounter += 1\n\nif counter == len(lst):\n\nreturn elem\n\nreturn total\n\ndef nth_part(lst, n):\n\ntotal = 0\n\ncounter"}
{"task_id":"task/29","completion":"\n\n# Calculate the sorted frequencies for each item in the list\n\nsorted_frequencies = sorted(Counter(lst).items(), key=operator.itemgetter(1), reverse=True)\n\n# Count how many items are in each frequency list\n\nn_items = sorted_frequencies."}
{"task_id":"task/30","completion":"\n\nif rad >= 180:\n\nreturn 180 + rad\n\nelse:\n\nreturn rad\n\ndef deg_to_rads(deg):\n\nif deg >= 360:\n\nreturn pi + deg\n\nelse:\n\nreturn deg\n\ndef start_angles(i):\n\nthis_angle = ["}
{"task_id":"task/30","completion":"\n\n'''\n\nConvert from radians to degrees\n\n'''\n\nreturn rad * (180.0 / pi)\n\ndef degrees_to_rads(deg):\n\n'''\n\nConvert from degrees to radians\n\n'''\n\nreturn deg * pi / 180.0\n\n"}
{"task_id":"task/30","completion":"\n\nreturn rad * pi / 180.0\n\ndef degs_to_rads(deg):\n\nreturn deg * pi / 180.0\n\ndef distance_between_points(p1, p2):\n\nx1, y1, z1 = p1\n\nx2, y2, z"}
{"task_id":"task/30","completion":"\n\nreturn rad * pi / 180.0\n\ndef degrees_to_rads(deg):\n\nreturn deg * 180.0 / pi\n\ndef draw_pixel(x, y, col):\n\nif x < 0 or x >= display.width or y < 0 or y >= display.height:\n\n"}
{"task_id":"task/30","completion":"\n\nreturn 180 * rad / pi\n\nprint \"RADS TO DEGREES:\", rads_to_degrees(42)\n\nprint \"DEGREES TO RADS:\", degrees_to_rads(45)\n\nKeyword Arguments\n\nKeyword arguments are the new standard way to pass"}
{"task_id":"task/31","completion":"\n\nn = max(n, 0)\n\ns = s + ' ' * (n // 2) + '...'\n\nfor i in range(n):\n\ns = s + ' '\n\nreturn s\n\n\n\ndef read_data(filename):\n\nwith open(filename, 'r') as"}
{"task_id":"task/31","completion":"\n\n\"\"\"\n\nConvert a string of repeated characters to a string of repeated\n\ncharacters. Example:\n\n>>> n_times_string(\"na\", 2)\n\n\"nananana\"\n\n\"\"\"\n\nreturn \" \".join(s * n)\n\ndef n_times_string(s, n"}
{"task_id":"task/31","completion":"\n\n\"\"\"\n\n:param s:\n\n:param n:\n\n:return:\n\n\"\"\"\n\nreturn f'{s} {n} times'\n\ndef _pipe_and_format(src, arg, n):\n\nreturn f'| {src} {arg} {n} |'\n"}
{"task_id":"task/31","completion":"\n\nif n == 0:\n\nreturn s\n\nreturn s + n_times_string(s, n-1)\n\n\n\ndef pos_str(s):\n\nreturn s[0]\n\n\n\ndef neg_str(s):\n\nreturn s[1:]\n\n\n\ndef binary_to_"}
{"task_id":"task/31","completion":"\n\nreturn \" {:>7} \".format(s) if n < 0 else \" {} {} \".format(s, n)\n\ndef\n\nis_prime\n\n(\n\nn\n\n):\n\nif\n\nn\n\n==\n\n2\n\n:\n\nreturn\n\nTrue\n\nelif"}
{"task_id":"task/32","completion":"\n\nreturn [fn(x) for x in obj]\n\n# like iteritems() but returns more than one value\n\ndef map_items(obj, fn):\n\nfor key, value in obj.items():\n\nyield fn(key), fn(value)\n\n# like iterkeys() but returns more"}
{"task_id":"task/32","completion":"\n\nresult = {}\n\nfor key, value in obj.items():\n\nif isinstance(value, list):\n\nresult[key] = map_values(value, fn)\n\nelse:\n\nresult[key] = fn(value)\n\nreturn result\n\n# Check that the instances of `sub"}
{"task_id":"task/32","completion":" for k, v in obj.items(): yield fn(k), v def unmap_values(obj, fn): for k, v in obj.items(): yield v, fn(k) def apply_to_all(obj, fn): for k, v in obj.items(): if isinstance(v, dict): if"}
{"task_id":"task/32","completion":"\n\nfor key in list(obj):\n\nobj[key] = fn(obj[key])\n\nreturn obj\n\n>>> map_values({'n': 'Niels', 'd': 'Dahl'}, key1=lambda x: x.upper())\n\n{'NIELS': 'Niels', '"}
{"task_id":"task/32","completion":"\n\nfor key in obj:\n\nif key not in '__dict__':\n\nfn(obj[key])\n\nelse:\n\nobj[key] = fn(obj[key])\n\nreturn obj\n\n\ndef filter_values(obj, fn):\n\nfor key in obj:\n\nif key not"}
{"task_id":"task/33","completion":"\n\n\"\"\"Convert hex RGB to actual RGB\"\"\"\n\nrgb = []\n\nfor x in hex:\n\nrgb.append(int(x, 16))\n\nrgb = tuple(rgb)\n\nrgb = tuple(int(x, 16) for x in rgb)\n\nreturn tuple("}
{"task_id":"task/33","completion":"\n\n\"\"\"\n\nConvert a hexadecimal color to a RGB value\n\n\"\"\"\n\nhex = hex.lower()\n\nif len(hex) == 6:\n\nr, g, b = hex_to_rgb_long(hex)\n\nelif len(hex) == 3:\n\n"}
{"task_id":"task/33","completion":"\n\nreturn ((hex[0], hex[1], hex[2])\n\n# #############################################################################\n\n# Colors\n\n# #############################################################################\n\ndef print_color(color):\n\nif color == 'black':\n\nprint('\\033[90m')\n\nelif color == '"}
{"task_id":"task/33","completion":"\n\n\"\"\"Convert a hex string to RGB.\"\"\"\n\nif len(hex) == 1:\n\n# If it's only one hex character, just return that.\n\nreturn int(hex, 16)\n\nreturn (int(hex[0:2], 16) << 12) + (int(hex[2"}
{"task_id":"task/33","completion":"\n\nreturn [ int (x, 16 ) for x in hex.split( '#' )[ 1 :]]\n\nif not tag or not tag.startswith( 'W' ):\n\nreturn None\n\ntry :\n\nwidth, height = int (tag[ 1 :], 16 ), int (tag[ 2"}
{"task_id":"task/34","completion":"\ndef split_string(string, sep):\ndef convert_str_to_int(str):\ndef get_int_str(str):\ndef main():\ndef main():\ndef main():\ndef main():\ndef main():\ndef main():\ndef main():\ndef main():\ndef main():\ndef"}
{"task_id":"task/34","completion":"\n\ndef copy_list(lst):\n\ndef is_true(x):\n\ndef find_digit(num, digits):\n\ndef copy_string(s):\n\ndef convert_base(num, numbase):\n\ndef get_random_list(list, size=5):\n\ndef main"}
{"task_id":"task/34","completion":"\ndef pickRandom(lst):\ndef isValidMove(moves, color, row, col):\ndef getRandomMove(board, color):\ndef getValidMoves(board, color):\ndef getWinningMove(board, color):\ndef whoWon(board, color):\ndef getBoardCopy"}
{"task_id":"task/34","completion":"\n\ndef to_LowerCase(lst):\n\ndef to_UpperCase(lst):\n\ndef to_TitleCase(lst):\n\ndef upper_Lower_letter(c):\n\ndef upper_Lower_letter2(c):\n\ndef upper_Lower_digit(c):\n\n"}
{"task_id":"task/34","completion":"\n\ndef add_comma(lst):\n\ndef remove_comma(lst):\n\ndef remove_comma_list(lst):\n\ndef remove_list_comma(lst):\n\ndef is_comma_list(lst):\n\ndef is_comma_list"}
{"task_id":"task/35","completion":"\n\nreturn len(lst) - 1 if fn(lst[0]) else 0\n\n\ndef filter_out_duplicates(lst):\n\nreturn [ x for x in lst if x not in lst[1:] ]\n\n\ndef find_item(lst, x):\n\nreturn l"}
{"task_id":"task/35","completion":" # order doesn't matter\n\nfor i in range(len(lst)):\n\nif fn(lst[i]):\n\nreturn i\n\nreturn -1\n\n\ndef is_divisible(n, d):\n\nreturn n % d == 0\n\n\ndef is_multiple(n, m):\n"}
{"task_id":"task/35","completion":"\n\nfor i in range(len(lst)):\n\nif fn(lst[i], lst[i+1]):\n\nreturn i\n\nreturn -1\n\n\n\n# Create a set with the letters of the alphabet\n\nalphabet = 'abcdefghijklmnopqrstuv"}
{"task_id":"task/35","completion":"\n\nfor i in range(len(lst)):\n\nif fn(lst[i]):\n\nreturn i\n\nreturn -1\n\n\ndef main():\n\nprint(find_index([\"Gerald\", \"Mike\", \"Harold\"],\n\nlambda x: \"Mike\" in x.lower()"}
{"task_id":"task/35","completion":"\n\n\"\"\"\n\nfind_index(lst, test) -> int\n\nreturns index of first occurrence of test in lst.\n\n>>> find_index(['a', 'a', 'b', 'b', 'c'], 'b')\n\n1\n\n>>> find_index(['a', '"}
{"task_id":"task/36","completion":"\n\n'''\n\nGiven a number, return the range that it is between\n\ninMin = lower bound\n\ninMax = upper bound\n\noutMin = minimum of the range\n\noutMax = maximum of the range\n\n'''\n\n#if inMin > inMax:\n\n# raise ValueError('"}
{"task_id":"task/36","completion":"\n\nif (num < inMin):\n\nnum = inMin\n\nelif (num > inMax):\n\nnum = inMax\n\nelif (num < outMin):\n\nnum = outMin\n\nelif (num > outMax):\n\nnum = outMax\n\nreturn num\n\n\ndef"}
{"task_id":"task/36","completion":"\n\n\"\"\"\n\nconvert a number to a range of [inMin, inMax]\n\n\"\"\"\n\nif num < inMin:\n\nnum = inMin\n\nif num > inMax:\n\nnum = inMax\n\nif num < outMin:\n\nnum = outMin\n\nif num >"}
{"task_id":"task/36","completion":"\n\n\"\"\"\n\nConvert a number (int or float) to a range of two numbers.\n\ninMin and inMax define the range the number is between\n\noutMin and outMax define the range the number will be converted to\n\n\"\"\"\n\nreturn (num - inMin) * (outMax - outMin"}
{"task_id":"task/36","completion":"\n\nif num < inMin:\n\nreturn False\n\nif num > inMax:\n\nreturn False\n\nif num <= inMax and num > outMin:\n\nreturn False\n\nif num <= outMin and num > outMax:\n\nreturn False\n\nif num == inMin or num == inMax"}
{"task_id":"task/37","completion":"\n\nreturn [item[0] for item in lst]\n\n\ndef main():\n\n# create a list of lists\n\nlst = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n\n# transpose the list\n\ntransposed = transpose(lst"}
{"task_id":"task/37","completion":"\n\nreturn [element for element in lst\n\nif element != 0]\n\nIn Python 3, the line return [element for element in lst\n\nif element != 0] is translated to return [element for element in lst if element != 0] so Python 3 code doesn\u2019t need an if statement.\n"}
{"task_id":"task/37","completion":"\n\ntranspose=[]\n\nfor elem in lst:\n\ntranspose.append(elem[::-1])\n\nreturn transpose\n\n\n\ndef reverse(lst):\n\nreverse=[]\n\nfor elem in lst:\n\nreverse.append(elem[::-1])"}
{"task_id":"task/37","completion":"\n\nreturn (map(lambda x: x.rot90(), lst))\n\n# print(transpose([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))\n\nprint(transpose([[1, 2, 3], [4, 5, 6], [7"}
{"task_id":"task/37","completion":"\n\nconverted = []\n\nfor x in lst:\n\nconverted.append([\"\", x])\n\nreturn converted\n\n\n\ndef get_data(n):\n\ndata = [[\"\",\"\"] for _ in range(n)]\n\nwhile len(data) > 0:\n\nx = random."}
{"task_id":"task/38","completion":" print num % 2 == 0 num = 1 is_even(num) # returns True because the modulus of 1 is 0 # So this example is equivalent to the following: def is_even(num): return num % 2 == 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21"}
{"task_id":"task/38","completion":"\n\n\"\"\"Returns True if the number is even, False otherwise. >>> is_even(2) True >>> is_even(3) False \"\"\"\n\ndef is_even(num):\n\n\"\"\"Returns True if the number is even, False otherwise. >>> is_even(2) True >>> is_even(3) False"}
{"task_id":"task/38","completion":"\n\n\"\"\" Checks if number is even \"\"\"\n\nif num % 2 == 0:\n\nreturn True\n\nelse:\n\nreturn False\n\ndef is_odd(num):\n\n\"\"\" Checks if number is odd \"\"\"\n\nif num % 2 == 1:\n\nreturn True\n\nelse:\n\nreturn False\n"}
{"task_id":"task/38","completion":"\n\nreturn num % 2 == 0\n\n\n\ndef reverse_input(input):\n\nx = input\n\nx_list = x[1:]\n\nx_list.reverse()\n\nx_list.reverse()\n\nx_list.reverse()\n\nx_list.reverse()\n\nx_list"}
{"task_id":"task/38","completion":" if num % 2 == 0: return True else: return False\n\n\nWe can then use this function in a conditional statement, as shown in the following code:\n\nif is_even(num): print(\"The number is even\") else: print(\"The number is odd\")\n\n\nWhen we run this code, we see the following"}
{"task_id":"task/39","completion":" return max(map(lambda x: x.index, arr))\n\nprint(max_element_index([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))\n\nprint(max_element_index([1, 2, 3, 4, 5, 6, 7, 8"}
{"task_id":"task/39","completion":"\n\n\"\"\"\n\nReturn the index of the max element in the given array.\n\nRaises a ValueError if the array is empty.\n\n\"\"\"\n\nreturn arr.index(max(arr))\n\ndef is_divisible_by(n, d):\n\n\"\"\"\n\nReturn True iff n is div"}
{"task_id":"task/39","completion":"\n\nreturn max(map(len, arr))\n\n\ndef merge_arrays(A, B):\n\nreturn [[min(x) for x in A] + B[0]]\n\n\ndef merge_sorted_arrays(A, B):\n\nreturn [[min(x) for x in A] +"}
{"task_id":"task/39","completion":" \"\"\" \u7b49\u5f85\u6570\u7ec4\u5143\u7d20\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\uff0c\u6bcf\u6b21\u53d6\u524dN\u4e2a\u5143\u7d20\uff0c\u6bcf\u6b21\u53d6\u524dN\u4e2a\u5143\u7d20"}
{"task_id":"task/39","completion":"\n\n\"\"\"\n\nReturn the index of the maximum element in a one-dimensional array\n\nof arbitrary type (presumably a list or tuple)\n\n\"\"\"\n\nreturn max(arr)\n\ndef max_element_index_cached(arr):\n\n\"\"\"\n\nReturn the index of the maximum element in a one"}
{"task_id":"task/40","completion":" return min(lst, key=lambda x: x[1], n = n + 1)\n\n>>> min_n([(2, 1), (1, 1), (4, 1), (4, 3), (2, 3), (3, 3), (3, 1), (3, 2), (3"}
{"task_id":"task/40","completion":"\n\nif len(lst) < n:\n\nlst = lst[:n] + [None] * (n - len(lst)) + lst[len(lst) + 1:]\n\nreturn lst\n\n\ndef gcd(a, b):\n\nwhile b != 0:\n"}
{"task_id":"task/40","completion":"\n\n\"\"\"\n\n:param lst: list of numbers\n\n:param n: minimum number\n\n:return: min number of the list\n\n\"\"\"\n\nif len(lst) < n:\n\nreturn n\n\nelse:\n\nreturn min(lst, key=lambda x: x[1])"}
{"task_id":"task/40","completion":"\n\nif lst and n < len(lst):\n\nreturn n\n\nelse:\n\nreturn 1\n\n\ndef expand_item(item):\n\nlst = []\n\nfor p in item:\n\nlst.append(p)\n\nreturn lst\n\n\ndef find_pair(items,"}
{"task_id":"task/40","completion":"\n\n# check if the list is empty, return 0 if so\n\nif len(lst) == 0:\n\nreturn 0\n\n# return the minimum value of the first n elements\n\nreturn min(lst[:n])\n\ndef partition(lst, n = 2):\n\n# return a list"}
{"task_id":"task/41","completion":" return itr[n-1] # Uncomment the following line if you have `random` in your # `site-packages` directory. It will use that random number # generator instead of the default `randint`. import random a = random.Random() for n in range(1, 15): # Sample from a uniform distribution between"}
{"task_id":"task/41","completion":" \"\"\" Take the next `n` elements from the iterable. \"\"\" next_iter = itr.__next__() if not next_iter: raise StopIteration elif n == 0: return itr elif n == 1: return next_iter else: return take_right(next_iter, n - 1) def"}
{"task_id":"task/41","completion":" \"\"\" \u53f3\u304b\u3089\u524d\u306e\u4f4d\u7f6e\u3092\u53d6\u5f97\u3059\u308b\uff08\u5de6\u304b\u3089\u3082\u53ef\uff09 :param itr: :param n: \"\"\" return itr[n:]\n\ntake_right\u3092\u4f7f\u3063\u3066\u4f8b\u3092\u66f8\u3044\u3066\u307f"}
{"task_id":"task/41","completion":"\n\n\"\"\"\n\nRemoves the rightmost _n_ characters from the given iterable.\n\n\"\"\"\n\nreturn _take_while_unicode(itr, lambda ch: ch < chr(n) + itr.rfind(chr(n)), n)\n\n\ndef take_until(itr"}
{"task_id":"task/41","completion":"\n\nyield from itr\n\nfor i in range(n):\n\nyield from itr\n\ndef take_left(itr, n = 1):\n\nitr.next()\n\nfor i in range(n):\n\nyield from itr\n\nprint(take_left(take_"}
{"task_id":"task/42","completion":"\n\n\"\"\"Return a list of unique items in a list\"\"\"\n\nreturn [ x for x in lst if x not in lst[1:] ]\n\ndef most_common(items, n=10):\n\n\"\"\"Return the n most common items in a list.\"\"\"\n\nreturn sorted(Counter(items).most"}
{"task_id":"task/42","completion":"\n\nunique = []\n\nfor x in lst:\n\nif x not in unique:\n\nunique.append(x)\n\nreturn unique\n\ndef sort_dict(d):\n\nreturn sorted(d.items(), key=operator.itemgetter(1), reverse=True)\n\ndef sort_"}
{"task_id":"task/42","completion":"\n\n'''filter unique of an integer array.'''\n\nc = Counter(lst)\n\nresult = []\n\nfor i in range(len(lst)):\n\n# \u5b58\u5728\u5219\u987a\u5e8f\u589e\u52a0\n\nif c[lst[i]] <"}
{"task_id":"task/42","completion":"\n\n\"\"\"Returns a list containing only unique items.\n\nTo keep the list sorted, you must pass in a function as a key argument to\n\nfunctools.update_wrapper().\n\n\"\"\"\n\nret = list(lst)\n\nkey = [f for f in sorted(ret)]\n\nreturn update_"}
{"task_id":"task/42","completion":"\n\nreturn list(set(lst))\n\ndef checkio(lst):\n\nif len(lst) <= 1:\n\nreturn []\n\nelse:\n\ncnt = Counter()\n\ncnt.update(lst)\n\ncheckio_keys = filter_unique(cnt.keys"}
{"task_id":"task/43","completion":"\n\n\n\nif n == 0:\n\nreturn lim\n\nprog = [1]\n\nwhile n != 0:\n\nif n & 1:\n\nprog.append(prog[-1] * 2)\n\nn = n >> 1\n\nprog = prog[1:] + prog[:-"}
{"task_id":"task/43","completion":" \"\"\"Compute the value of n in an arithmetic progression using the binary notation. It does not go beyond the limit lim. >>> arithmetic_progression(1, 5) [1, 2, 3, 4] >>> arithmetic_progression(1, 100) [1, 2, 3, 4, 5, 6, 7, 8"}
{"task_id":"task/43","completion":"\n\nz = 1\n\nwhile True:\n\nyield z\n\nz = z*z+n\n\nif z>lim: break\n\n# naturals, naturals+1, naturals+2,...\n\ndef natural_arithmetic_progression(n, lim):\n\nyield"}
{"task_id":"task/43","completion":" if (n == 0): return 0 if (n == 1): return lim if (n < 0): return -1*arithmetic_progression(n, lim) s = 0 for i in range(1, n+1): s += i*lim return s\n\nLet's call this with the function input n = 5"}
{"task_id":"task/43","completion":" \"\"\" Compute the arithmetic progression that results in the value of n when it is added to the number in the lim list. >>> arithmetic_progression(5, [1, 2, 3, 4]) [5, 7, 9, 11] >>> arithmetic_progression(5, [4, -2, 6, -1])"}
{"task_id":"task/44","completion":" for d in dicts: for k, v in d.items(): if v is not None: setattr(d, k, v)\n\nThis function is the one that actually does the heavy lifting. It takes a list of dictionaries as its argument, loops over each one, and merges the values of each key in the"}
{"task_id":"task/44","completion":" \"\"\"Merge dicts together. If a key is present in more than one dict, the rightmost value is kept. >>> list(merge_dictionaries([{'a': 1}, {'a': 2}], [{'a': 1}, {'a': 3}])) [{'a': 2}"}
{"task_id":"task/44","completion":" \"\"\"Merge multiple dictionaries together into one\"\"\" return dict(zip(dicts, repeat=3)) def check_product(p): \"\"\"Check to see if a product is valid\"\"\" if not p: raise ValueError('A product must be specified') if len(p) != 2: raise ValueError('A product must have two"}
{"task_id":"task/44","completion":" \"\"\"Merge a list of dictionaries. Examples: >>> merge_dictionaries({'a': 1, 'b': 2}, {'a': 3, 'b': 4}) {'a': 3, 'b': 4} >>> merge_dictionaries({'a': 1, 'b': 2}, {'a"}
{"task_id":"task/44","completion":" + \"\"\"Merge one dictionary into another. + + Merges dicts recursively and returns a new dictionary that contains + every key-value pair from all the arguments. Merging dictionaries + with different types (e.g. by a list and a dict) will result in an + error. + + In case of a conflict"}
{"task_id":"task/45","completion":"\n\n\"\"\"\n\n@param lst list or tuple of tuples\n\n@param indexes optional list of indexes\n\n@param reverse whether to reverse the order of the final sorted list\n\n@return sorted list of tuples\n\n\"\"\"\n\nif not indexes:\n\nreturn lst\n\nindexes = indexes[:]"}
{"task_id":"task/45","completion":"\n\nif reverse:\n\nindexes = indexes[::-1]\n\nreturn reduce(lambda result, i: result + i, lst, [])\n\ndef is_power_of_2(x):\n\n\"\"\"Returns True if x is a power of 2, False otherwise.\n\nArgs:\n\n"}
{"task_id":"task/45","completion":"\n\nreversed = reversed and not reverse\n\nif not indexes:\n\nreturn lst\n\nindexes = [int(x) for x in indexes]\n\nd = {}\n\nfor i, x in enumerate(lst):\n\nd[indexes[i]] = i\n\nif reverse:"}
{"task_id":"task/45","completion":"\n\n'''\n\nsort_by_indexes(lst, indexes, reverse=False)\n\nsorts the list in place, based on the indexes in the\n\nindexes list. If reverse is True, the list is sorted in reverse\n\norder.\n\n'''\n\nif reverse:\n\nneg"}
{"task_id":"task/45","completion":" # sort list ascending, or descending if reverse is True indexes = list(indexes) indexes.reverse() if reverse else indexes return lst[indexes]\n\n\n\nI'd like to use this as follows\n\n\n\n\n\nsort_by_indexes([9,2,1,8,7,6,5,4"}
{"task_id":"task/46","completion":"\ndef get_all(d, selectors):\ndef get_or_set(d, selector, value):\ndef set(d, selector, value):\ndef add(d, key, value):\ndef remove(d, key):\ndef clear(d):\ndef copy(d):\ndef copy_if"}
{"task_id":"task/46","completion":"\nclass EventListener:\n\ndef add_handler(self, evt, handler):\ndef remove_handler(self, evt, handler):\n\nclass Context(object):\n\nclass LifeCycleManager(object):\n\nclass App(Context):\n\ndef __init__(self, *args, **kw"}
{"task_id":"task/46","completion":"\n\ndef make_indexer(arg_names, *selectors):\n\ndef _arg_getter(arg_name):\n\ndef _arg_setter(arg_name, value):\n\ndef _arg_deleter(arg_name):\n\ndef make_argument_parser(arg_names"}
{"task_id":"task/46","completion":"\n\ndef set(d, selectors, value):\n\ndef inc(d, selectors):\n\ndef dec(d, selectors):\n\ndef get_ (d, selectors):\n\ndef set_ (d, selectors, value):\n\ndef inc_ (d, selectors):\n\ndef"}
{"task_id":"task/46","completion":"\n\ndef add(d, selectors):\n\ndef update(d, selectors):\n\ndef text(d, selectors):\n\ndef select(d, selectors):\n\ndef __add__(self, other):\n\ndef __iadd__(self, other):\n\ndef __isub__"}
{"task_id":"task/47","completion":"\n\nreturn [lst[x] for x in range(0, len(lst) - 1) if fn(lst[x], lst[x+1])]\n\n\ndef append_to_end(lst, x):\n\nreturn lst + [x]\n\n\ndef print_tree("}
{"task_id":"task/47","completion":" return lst[0:len(lst)-fn(lst[0])] + bifurcate_by(lst, lambda x: x%2)\n\n\nHow it works...\n\n\nThe function bifurcate_by creates a list from two halves of the list passed to it as an argument"}
{"task_id":"task/47","completion":" \"\"\"Bifurcate a list at every occurence of a value. \"\"\" if not lst: return [] bfs = [] while True: try: bfs.append(fn(lst.pop(0))) except ValueError: break return bfs def filter_by(lst, fn): \"\"\"Filter a list"}
{"task_id":"task/47","completion":" \"\"\"Split list in two at position where function returns true\"\"\" mid = len(lst)//2 lst1 = lst[:mid] lst2 = lst[mid:] return lst1, lst2 def main(): for i in range(10): if i % 2 == 0: lst1, l"}
{"task_id":"task/47","completion":"\n\n\"\"\"Divide list in two\"\"\"\n\nfor i in range(len(lst)//2):\n\nlst.insert(i, lst[i+1])\n\nreturn lst\n\n\ndef print_list(lst):\n\n\"\"\"Display contents of list\"\"\"\n\nfor i in range("}
{"task_id":"task/48","completion":" if n < 2: return n else: return fibonacci(n-1) + fibonacci(n-2)\n\nthe execution of the above code is straightforward:\n\nfibonacci(1) will return 1\n\nwill return fibonacci(2) will return 1\n\nwill return fibonacci"}
{"task_id":"task/48","completion":" if n <= 1: return n else: return fibonacci(n-1) + fibonacci(n-2) print(fibonacci(3))\n\nIn the above example, the number of times fibonacci is called is equal to the n-1st and n-2nd Fibonacci numbers."}
{"task_id":"task/48","completion":" if n < 2: return n return fibonacci(n-1) + fibonacci(n-2) def fibonacci_iterative(n): a, b = 0, 1 while a < n: yield a a, b = b, a+b\n\nFibonacci is a classic example for a"}
{"task_id":"task/48","completion":" a, b = 0, 1 for i in range(n): a, b = b, a + b return a\n\nWe can do that because the Python interpreter does what we need: it can evaluate any Python expression, which includes calling any Python function.\n\nHow does it do this? When it evaluates a call to fibon"}
{"task_id":"task/48","completion":" if n < 2: return n else: return fibonacci(n-1) + fibonacci(n-2) print(fibonacci(8)) Output: 13\n\nA Fibonacci sequence is an integer sequence where each element is the sum of the previous two elements. It is an example of a recursive sequence"}
{"task_id":"task/49","completion":" for word in obj: for entry in word.split(): if entry in DICTIONARY: DICTIONARY[entry] = 1 / DICTIONARY[entry] elif entry in DICTIONARY_REVERSE: DICTIONARY_REVERSE[entry] = 1 / DICTIONARY_RE"}
{"task_id":"task/49","completion":"\n\nif obj is not None:\n\nif isinstance(obj, dict):\n\nobj = dict(invert_dictionary(obj))\n\nreturn obj\n\n\nInvert.invert_dictionary(dict(foo='bar'))\n\n# => dict(bar='foo')\n\n\nInvert.in"}
{"task_id":"task/49","completion":" for key in obj: obj[key] = obj[key] ^ 1\n\nHere\u2019s what happens:\n\n>>> def invert_dictionary(obj): ... for key in obj: ... obj[key] = obj[key] ^ 1 ... >>> invert_dictionary({'a': 1, 'b"}
{"task_id":"task/49","completion":"\n\n''' invert dictionary `obj`\n\nThe dictionary is inverted so that keys become values and vice versa.\n\n>>> invert_dictionary({'a': 1, 'b': 2, 'c': 3})\n\n{'1': 'a', '2': 'b', '3': 'c'"}
{"task_id":"task/49","completion":" if isinstance(obj, dict): return dict(reversed(obj)) else: return obj\n\nAs you can see, the implementation is fairly straightforward:\n\nThe invert_dictionary function takes in a dictionary as an argument, and returns a new dictionary by reversing the key-value pairs in the given dictionary.\n\n"}
{"task_id":"task/50","completion":"\n\ndef ucfirst(s):\n\nif s[0] not in 'abcdefghijklmnopqrstuvwxyz':\n\nraise ValueError\n\nreturn s[0].upper() + s[1:]\n\nreturn sub(lambda m: m.upper() + ucfirst("}
{"task_id":"task/50","completion":"\n\n\"\"\"Camel case converter\"\"\"\n\nreturn s.replace('_', '-')\n\ndef get_package_name(filename):\n\n\"\"\"Try to get the package name from a filename\"\"\"\n\nfor _, ext in six.iteritems(['zip', 'egg', 'tar.gz', 'tar."}
{"task_id":"task/50","completion":"\n\nreturn s.replace(\u2018_\u2019, \u2018-\u2018)\n\ndef lower(s):\n\nreturn s.lower()\n\ndef upper(s):\n\nreturn s.upper()\n\ndef numeral(s):\n\nreturn s\n\ndef ascii(s):\n\n"}
{"task_id":"task/50","completion":"\n\nreturn s.lower().replace(' ', '_')\n\ndef word(s):\n\nreturn s.lower().replace(' ', '_')\n\ndef is_camel(s):\n\nreturn word(s)[0] in ['A', 'a', 'B', 'b', 'C', 'c"}
{"task_id":"task/50","completion":"\n\nif isinstance(s, str):\n\nreturn s.lower()\n\nreturn s\n\n\ndef main():\n\nfor i in range(20):\n\nline = raw_input('Enter line {0}: '.format(i + 1))\n\nif not line:\n\ncontinue\n\nres = camel"}
{"task_id":"task/51","completion":"\n\n# Convert the array of values into a Python string.\n\nreturn ','.join(str(v) for v in d.values())\n\n\ndef key_of_max(d):\n\n# Convert the array of values into a Python string.\n\nreturn ','.join(str(v) for v"}
{"task_id":"task/51","completion":"\n\nreturn d[-1]\n\ndef min(d):\n\nif len(d) < 2:\n\nreturn d[0]\n\nelse:\n\nreturn min_by_key(d)\n\ndef min_by_key(d):\n\nif len(d) == 2:\n\n"}
{"task_id":"task/51","completion":"\n\n\"\"\"\n\nReturn the key of the minimum element in d.\n\n\"\"\"\n\nreturn sorted(d)[0]\n\ndef key_of_max(d):\n\n\"\"\"\n\nReturn the key of the maximum element in d.\n\n\"\"\"\n\nreturn sorted(d)[-1]\n\nclass My"}
{"task_id":"task/51","completion":"\n\n+ return ord(d.key())\n\n+\n\n+def key_of_max(d):\n\n+ return -ord(d.key())\n\n+\n\n+# This is a hack to get custom sort order.\n\n+def key_of_swap(d):\n\n+ return"}
{"task_id":"task/51","completion":"\n\nreturn min_key(d)\n\ndef key_of_max(d):\n\nreturn max_key(d)\n\ndef get_key_of_min(d):\n\nreturn min_key(d)[0]\n\ndef get_key_of_max(d):\n\nreturn max"}
{"task_id":"task/52","completion":"\n\n\"\"\"\n\nReturn a capitalized version of the string.\n\n\"\"\"\n\nif s:\n\nreturn s.capitalize()\n\nreturn s\n\ndef disable_recursive_call_limit(enable):\n\n\"\"\"\n\nDisable recursive call limit. This can be used in cases where\n\nthe limit is"}
{"task_id":"task/52","completion":" s = s.lower() if s[0] in '!'*rest_char: rest_char = s[0] s = s[1:] return s.capitalize()\n\nTo go back to the input/output example, this time we capitalize the output for the !-input (output below is for the same input"}
{"task_id":"task/52","completion":" \"\"\"Return a string with first letter of each word in uppercase and the rest in lowercase.\"\"\" if lower_rest: s = s.lower() for i, c in enumerate(s): if i >= len(s) - 1: break if c.isupper(): s[i] = c.lower() else"}
{"task_id":"task/52","completion":" \"\"\"capitalize(s) -> string Return a copy of the string s with only its first character, if any, capitalized. The optional argument lower_rest is a flag indicating whether the rest of the string should also be capitalized. \"\"\" s = s.lower() if s.isupper(): return s.capitalize() return s"}
{"task_id":"task/52","completion":"\n\n\"\"\"\n\nreturn a copy of s with all lowercase letters replaced with\n\nuppercase letters. If `lower_rest` is True, then the first\n\nuppercase letter of the string is kept unchanged.\n\n\"\"\"\n\nreturn s.capitalize() + s[:1] if lower_rest"}
{"task_id":"task/53","completion":"\n\nreturn degrees * (5.0/9.0) + 32.0\n\n\nThe value is returned from the function, but it was a temporary value used only for the calculation. The return statement returns the value of the expression. If the expression is a simple expression that doesn\u2019t need to be evaluated, you can omit"}
{"task_id":"task/53","completion":"\n\ndegrees = (degrees - 32) * 5 / 9\n\nreturn degrees\n\n\ndef convert_to_celsius(degrees_fahrenheit):\n\ndegrees_fahrenheit = (degrees_fahrenheit - 32) * 9 / 5 + 32\n\nreturn degrees_fahrenheit"}
{"task_id":"task/53","completion":"\n\ndegrees = degrees - 32.0\n\nreturn degrees\n\nThe conversion from Celsius to Fahrenheit is negative because the formula adds 32.0 to the Celsius value before converting.\n\nThe conversion from Fahrenheit to Celsius is not negative because the formula subtracts 32.0 from the Fahrenheit value before converting.\n\nNow we can rewrite"}
{"task_id":"task/53","completion":"\n\nreturn degrees * (9.0 / 5.0) + 32.0\n\n\ndef fahrenheit_to_celsius(degrees):\n\nreturn degrees * (5.0 / 9.0) + 32.0\n\n\ndef conversion(degrees):\n\nreturn fahrenheit_to_cel"}
{"task_id":"task/53","completion":" return degrees * (5.0 / 9.0) + 32.0\n\nAnother way of adding function overloading is to use *args and **kwargs. In this case, both *args and **kwargs represent a \u201chole\u201d in the function signature. For example, consider the following function:\n\ndef add"}
{"task_id":"task/54","completion":"\n\n\"\"\"\n\nReturn a list of every nth element of a list, in order.\n\n>>> lst = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n>>> lst = every_nth(lst, 2)\n\n>>> lst\n\n[1"}
{"task_id":"task/54","completion":" \"\"\" Return a list of every nth element in the input list. The first element in the output list is the first element in the input list, followed by every nth element following that (e.g. the second element in the output list is the second element in the input list, followed by every third element following that, etc.). If"}
{"task_id":"task/54","completion":"\n\nfor i in range(len(lst)):\n\nif lst[i] == nth:\n\nyield i\n\ndef every_nth2(lst, nth):\n\nfor i in range(len(lst)):\n\nif lst[i] == nth:"}
{"task_id":"task/54","completion":"\n\n\"\"\"Return a copy of lst, every nth element is changed to the nth\n\nelement of the sublist returned by `i % nth`.\"\"\"\n\nnew_lst = []\n\nfor i in lst:\n\nif i % nth == 0:\n\nnew_lst."}
{"task_id":"task/54","completion":" \"\"\" Returns every nth element of lst, starting from the first one. \"\"\" count = 0 for el in lst: if count % nth == 0: yield el count += 1"}
{"task_id":"task/55","completion":"\n\n'This is the union function'\n\ndef intersect(a, b):\n\n'This is the intersect function'\n\ndef difference(a, b):\n\n'This is the difference function'\n\ndef symmetric_difference(a, b):\n\n'This is the symmetric difference function'\n"}
{"task_id":"task/55","completion":" \"\"\"Produce a new object which is a union of a and b\"\"\" return a | b\n\n\nIn this code, the union function takes two arguments, a and b, and returns a new object, which is a union of a and b. Notice that the syntax used to define union is the same as the syntax used for functional expressions,"}
{"task_id":"task/55","completion":" print(\"a and b\") y = False union(y, True) print(y)\n\n\nWhen you run this program, you will get the following output:\n\n\nFalse\n\n\n7. The Difference between \"not a\" and \"not a or b\" is:\n\n\nWhen you have a simple variable like y, there is"}
{"task_id":"task/55","completion":" # Constructor return a.id + b.id\n\nMethod decorators\n\nThis feature is still considered experimental, so it might change in future versions.\n\nMethod decorators are a new feature in Python 3.0. Method decorators are similar to class decorators, but they are used on methods instead of classes.\n\n"}
{"task_id":"task/55","completion":" return [a, b]\n\n>>> x = union(1, 2)\n\n>>> x\n\n[1, 2]\n\n>>> y = union(1, 2, 3)\n\n>>> y\n\n[1, 2, 3]\n\n>>> z = union(1, 2, 3, 4)\n"}
{"task_id":"task/56","completion":"\n\nreturn (a[0], len(a))\n\nN = len(a)\n\nif N <= 0:\n\nreturn (a, 1)\n\nreturn (drop(a[1:N], N - 1), N)\n\n\"\"\"\n\nIf there are less than two elements in the array a,"}
{"task_id":"task/56","completion":" # def drop(a, n = 1): \u2212 if n == 0: + if n == 0: \u2212 return a + return a \u2212 if n == 1: + if n == 1: \u2212 return a + return a \u2212 for i in range(n - 1): + for i in range(n - 1): \u2212 if not a"}
{"task_id":"task/56","completion":"\n\nwhile True:\n\nif n == 0:\n\nreturn a\n\na, n = a[1:], n-1\n\nreturn a\n\n\ndef swap(a, i, j):\n\nt = a[i]\n\na[i] = a[j]\n\na[j]"}
{"task_id":"task/56","completion":"\n\nwhile a > 0:\n\na -= n\n\nprint(a)\n\n\ndef add(a, b):\n\nreturn a + b\n\n\ndef mult(a, b):\n\nreturn a * b\n\n\ndef div(a, b):\n\nreturn a / b\n\n\ndef pow(a,"}
{"task_id":"task/56","completion":"\n\nif n > 0:\n\nif n % 2 == 0:\n\nreturn a\n\nelse:\n\nreturn a + drop(a, n - 1)\n\nelif n == 0:\n\nreturn a\n\nelse:\n\nraise Exception('Wrong number of arguments for a drop function')\n\n"}
{"task_id":"task/57","completion":"\n\nn = len(lst)\n\np = defaultdict(int)\n\nfor i in range(n):\n\np[lst[i]] += 1\n\nreturn p\n\nlst = [1,1,2,2,2,3,3,3,3,3,3,"}
{"task_id":"task/57","completion":"\n\nfreq = defaultdict(int)\n\nfor x in lst:\n\nfreq[x] += 1\n\nreturn freq\n\ndata = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17"}
{"task_id":"task/57","completion":"\n\n\"\"\"Count the frequency of each symbol in a list\"\"\"\n\nfreq = defaultdict(int)\n\nfor x in lst:\n\nfreq[x] += 1\n\nreturn freq\n\ndef freqdist(lst):\n\n\"\"\"Return a list of frequencies of each symbol in a list\"\"\""}
{"task_id":"task/57","completion":"\n\nx = defaultdict(int)\n\nfor i in lst:\n\nx[i] += 1\n\nreturn x\n\nprint(frequencies([1,2,3,4,5,6,7,8,9,10]))\n\nWhich of the following is not a truth value?"}
{"task_id":"task/57","completion":"\n\ntotal = 0\n\nfor n,v in lst:\n\ntotal += v\n\nfrequencies = defaultdict(int)\n\nfor n,v in lst:\n\nfrequencies[n] += 1\n\nreturn frequencies\n\ndef bar(total, data):\n\nprint(\u201c"}
{"task_id":"task/58","completion":" # This is a generator function. It *could* be a simple function, # but it's a generator function because it's convenient to just # keep calling it to get more elements. end = start step = step while end < start: yield start start += step\n\n\"\"\"\n\nfor i in range(1, 10):\n\n"}
{"task_id":"task/58","completion":"\n\nnew_list = []\n\nwhile start < end:\n\nnew_list.append(start)\n\nstart += step\n\nreturn new_list\n\n\ndef range_to_list(start, end, step = 1):\n\nnew_list = []\n\nwhile start < end:\n\nnew_"}
{"task_id":"task/58","completion":"\n\n'''initialize_list_with_range(end, start=0, step=1) returns\n\na list containing all numbers between start and end,\n\ninclusive, and separated by step. If start is greater than\n\nend, an empty list is returned.\n\n'''\n\nreturn [start"}
{"task_id":"task/58","completion":"\n\n\"\"\"\n\nReturn a list containing the numbers between start and end,\n\nwith step elements between consecutive numbers.\n\n\"\"\"\n\nif step == 0:\n\nstep = 1\n\nreturn list(range(start, end + step, step))\n\n\n\ndef print_list(list_of_ints):\n"}
{"task_id":"task/58","completion":"\n\n\"\"\"Create a new list of end-start elements, in steps of\n\nend-start, defaulting to 1.\"\"\"\n\nreturn [start] + list(itertools.repeat(start, step))\n\n\ndef add_all_segments(path, a, b, end):\n\n\"\"\"Add all"}
{"task_id":"task/59","completion":"\n\nresult = list(lst)\n\nfor x in lst:\n\nresult.append(x)\n\nreturn accumulate(result, 0)\n\ndef cumprod(lst):\n\nresult = list(lst)\n\nfor x in lst:\n\nresult.append(x)\n"}
{"task_id":"task/59","completion":"\n\ncum = sum(lst)\n\nreturn list(accumulate(lst, cum))\n\ndef main():\n\n# Add some numbers\n\nprint(cumsum([3,4,5]))\n\n# Remove the even numbers\n\nprint(cumsum([1,2,3,"}
{"task_id":"task/59","completion":"\n\ns = []\n\nfor e in lst:\n\ns.append(s[-1] + e)\n\nreturn s[-1]\n\ndef nth_c(n, c):\n\nreturn lambda lst: lst[n] * c\n\ndef nth_c_acc"}
{"task_id":"task/59","completion":"\n\ncumsum = []\n\nfor i in lst:\n\ncumsum.append(cumsum[-1] + i)\n\nreturn cumsum[-1]\n\n#comparison of the cumsum between the two date arrays\n\ndef compare(lst1, lst"}
{"task_id":"task/59","completion":"\n\nreturn accumulate(lst, 0)\n\nThe cumsum function uses itertools.accumulate to merge successive values from the given list into a cumulative sum, which it returns. The accumulator argument to accumulate is 0 for the first element in the list, and then the sum of the previous two elements for the second"}
{"task_id":"task/60","completion":"\n\n\"\"\"\n\n:param start:\n\n:param end:\n\n:return:\n\n\"\"\"\n\nreturn (end - start) * 12\n\ndef calculate_days_diff(start, end):\n\n\"\"\"\n\n:param start:\n\n:param end:\n\n:return:\n\n\"\"\"\n"}
{"task_id":"task/60","completion":"\n\n''' Calculates the difference in months between two datetimes '''\n\nstart_date = datetime.datetime.strptime(start, '%Y-%m-%d')\n\nend_date = datetime.datetime.strptime(end, '%Y-%m-%"}
{"task_id":"task/60","completion":"\n\n\"\"\"Returns the number of months between two datetimes.\n\nIf one date is later than the other, it will be negative.\n\n\"\"\"\n\nend = end.replace(day=1)\n\nreturn end - start + 1\n\ndef december_months(year):\n\n\"\"\"Returns the number of months"}
{"task_id":"task/60","completion":"\n\nwhile start < end:\n\nstart += 1\n\nwhile start >= end:\n\nstart -= 1\n\nreturn months_diff(start, end)\n\ndef days_diff(start, end):\n\nwhile start < end:\n\nstart += 1\n\nwhile start >= end:\n\nstart -= 1"}
{"task_id":"task/60","completion":"\n\nreturn ceil((end - start) / 30.43)\n\ndef years_diff(start, end):\n\nreturn ceil((end - start) / 365.25)\n\ndef total_diff(start, end):\n\nreturn (months_diff(start, end) + years_diff(start"}
{"task_id":"task/61","completion":"\n\nreturn defaultdict(list)\n\nclass Tuple(collections.namedtuple('Tuple', ['a', 'b'])):\n\npass\n\ntest = Tuple(1, 2)\n\ntest.a, test.b = 0, 0\n\ntest.a, test.b = 3"}
{"task_id":"task/61","completion":"\n\n\"\"\"Turn an object into a dictionary.\"\"\"\n\nif isinstance(obj, dict):\n\nreturn obj\n\nelif isinstance(obj, list):\n\nreturn defaultdict(obj)\n\nelif isinstance(obj, set):\n\nreturn defaultdict(set)\n\nelif isinstance("}
{"task_id":"task/61","completion":"\n\nif isinstance(obj, dict):\n\nreturn obj\n\nelse:\n\nreturn defaultdict(obj)\n\ndef write_to_log_file(log_file, line):\n\nwith open(log_file, 'a') as log_file:\n\nlog_file.write(line)"}
{"task_id":"task/61","completion":"\n\nif type(obj) is not list:\n\nobj = [obj]\n\nd = defaultdict(int)\n\nfor item in obj:\n\nd[str(item[0])] += 1\n\nreturn d\n\ndef main():\n\n\"\"\"\n\nThis example of using defaultdict with a factory"}
{"task_id":"task/61","completion":"\n\n\"\"\"Collect an object's dictionary contents into a list.\n\nReturn a list of the keys of the object's dictionary.\n\n\"\"\"\n\nd = {}\n\nfor key in dir(obj):\n\nd[key] = getattr(obj, key)\n\nreturn d.keys()\n\ndef print_"}
{"task_id":"task/62","completion":"\n\nif k == 0:\n\nreturn n\n\nelif k == 1:\n\nreturn n * n\n\nelse:\n\nreturn n * binomial_coefficient(n - 1, k - 1) * binomial_coefficient(n - 1, k)\n\ndef factorial(n):\n"}
{"task_id":"task/62","completion":"\n\nif k == 0:\n\nreturn n\n\nelif k == 1:\n\nreturn n\n\nelse:\n\nreturn n * binomial_coefficient(n-1, k-1) + binomial_coefficient(n-1, k)\n\nfor i in range(1, 1001"}
{"task_id":"task/62","completion":"\n\n\"\"\"\n\nReturns binomial coefficient(n, k)\n\n\"\"\"\n\nif k < 0 or k > n:\n\nraise ZeroDivisionError( ' %d k must be >= 0 and < %d ' % (k, n))\n\nif k == 0 :\n\nreturn 1\n\nc ="}
{"task_id":"task/62","completion":"\n\nb = 1\n\nfor i in range(n):\n\nb *= (i + k) // (n - i)\n\nreturn b\n\ndef power_binary(p):\n\nreturn binomial_coefficient(2, p)\n\ndef power_unary(p):\n\nreturn bin"}
{"task_id":"task/62","completion":"\n\nif k <= 0:\n\nreturn 0\n\nelse:\n\nreturn n * binomial_coefficient(n-1, k-1) +\n\nbinomial_coefficient(n-1, k)\n\ndef factorial(n):\n\nreturn n if n < 0 else n * factorial"}
{"task_id":"task/63","completion":"\n\n\"\"\"\n\nReturn list of all keys in dict\n\n\"\"\"\n\nreturn [k for k in dict.keys() if val in dict[k]]\n\n\n\ndef extract_keys(dict, val):\n\n\"\"\"\n\nReturn list of all keys in dict that are NOT equal to val\n\n\"\"\"\n\nreturn"}
{"task_id":"task/63","completion":"\n\nfor key in dict:\n\nif key == val:\n\nreturn key\n\nreturn None\n\n\ndef find_key_val(dict, key, val):\n\nfor key in dict:\n\nif key == key:\n\nreturn val\n\nreturn None\n\n\ndef main():\n\nif __name__"}
{"task_id":"task/63","completion":"\n\n1176 n/a if dict.has_key(val):\n\n1177 n/a return dict[val]\n\n1178 n/a\n\n1179 n/a # simple dicts\n\n1180 n/a d = {1:1, 2:2}\n\n1181 n/"}
{"task_id":"task/63","completion":"\n\nif dict.has_key(val):\n\nreturn val\n\nelse:\n\nreturn find_keys(dict, val, 2)\n\ndef merge_dicts(dict1, dict2):\n\nif dict1 == dict2:\n\nreturn dict1\n\nelif dict1 == {}:\n"}
{"task_id":"task/63","completion":"\n\nif dict.has_key(val):\n\nreturn [val]\n\nelse:\n\nreturn []\n\ndef get_all_keys(dict):\n\nreturn find_keys(dict, None)\n\ndef get_all_values(dict):\n\nreturn find_keys(dict, None)\n"}
{"task_id":"task/64","completion":" super().when(predicate, when_true) return True return super().when(predicate, when_true) when_true.connect(lambda: print(\"Fired when predicate returns True\")) when_false.connect(lambda: print(\"Fired when predicate returns False\"))\n\nLambda expressions are also used to provide"}
{"task_id":"task/64","completion":" return when_true def unless(predicate, unless_true): return unless_true >>> do_something() if when_test() >>> do_something() unless unless_test() else: >>> do_something() if when_test() else: >>> do_something() unless unless_test()\n\nThe first two examples are rather"}
{"task_id":"task/64","completion":" ... with self.assertRaises(RuntimeError): pass def test_should_get_absolute_url(self): \"\"\" Test that get_absolute_url() should return a URL including the protocol \"\"\" url = self.g.get_absolute_url() url = url.replace(self.g.protocol, '') self"}
{"task_id":"task/64","completion":"\n\nreturn function(self, *args, **kwargs):\n\nreturn predicate(self, *args, **kwargs)\n\n\ndef also(predicate, when_true):\n\nreturn when(predicate, lambda self: also(predicate, when_true))\n\n\ndef login(username, password):\n"}
{"task_id":"task/64","completion":"\n\n\"\"\"\n\nReturns True if the predicate is true for any of the elements.\n\n\"\"\"\n\n# Returns False if predicate is True for all the elements\n\n# and returns True if predicate is True for any of the elements\n\nif predicate(element):\n\nreturn True\n\nelse:\n\nreturn False\n\n"}
{"task_id":"task/65","completion":"\n\n\"\"\"\n\n:param lst: list\n\n:param n: number of elements in each chunk\n\n:return: list of chunks\n\n\"\"\"\n\nremainder = lst[0]\n\nwhile len(remainder) > 0 and n > 0:\n\nchunk = []\n\nfor"}
{"task_id":"task/65","completion":"\n\nlst = lst[1:]\n\nfor j in range(0, n, 2):\n\nlst = lst[:-2] + lst[2:]\n\nreturn lst\n\ndef merge_dicts(d1, d2):\n\nif d1.get(k, None"}
{"task_id":"task/65","completion":"\n\nreturn [lst[i:i+n] for i in range(0, len(lst), n)]\n\ndef left_pad(text, pad=0):\n\nreturn text + pad * (len(text) % pad)\n\ndef center_align(text, pad=0):\n\n"}
{"task_id":"task/65","completion":"\n\n'''\n\nlst is a sequence of arbitrary objects\n\nn is the length of each chunk of lst\n\nreturns a sequence of n - 1 lists containing the last element of lst\n\n'''\n\nresult = []\n\nwhile lst and len(lst) > 0:\n\nresult"}
{"task_id":"task/65","completion":"\n\n\"\"\"Chunk a list into n size pieces and return the list of pieces.\"\"\"\n\nif len(lst) < n:\n\nreturn [lst]\n\nremainder = len(lst) % n\n\npieces = []\n\nfor i in range(0, n, remainder):\n\n"}
{"task_id":"task/66","completion":" return km / 1000.0 # Convert km to miles miles = km_to_miles(10) print(miles) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43"}
{"task_id":"task/66","completion":"\n\nreturn float(km) / 1000.0 * 1.60934 # [miles]\n\ndef psi_to_kpa(psi):\n\nreturn psi * 0.06854 # [kPa]\n\ndef kpa_to_atm(kpa):\n\nreturn kpa * 101"}
{"task_id":"task/66","completion":"\n\nreturn km * 1.609\n\n\ndef miles_to_km(miles):\n\nreturn miles / 1.609\n\n\ndef main():\n\nprint km_to_miles(30_000_000), miles_to_km(30_000_000)\n\n\nif __name__ == '__"}
{"task_id":"task/66","completion":"\n\nkm = km / 1.609\n\nreturn km\n\n\nIt was easier to convert the original km_to_miles() function to a new one that accepts a km value rather than an integer. This allows you to apply any kind of numeric input as a km value.\n\nNow that we have a reusable function, let"}
{"task_id":"task/66","completion":" return km/1000.0 def miles_to_km(miles): return miles/1000.0 def convert_time(hrs,mins,secs): return hrs*60+mins*60+secs def calculate_distance(from,to): dist = convert_time(to[1],to[2],to"}
{"task_id":"task/67","completion":" \"\"\"Return the max value of a list according to a function. >>> max_by(['a', 'b', 'c'], str.lower) 'b' >>> max_by(['a', 'b', 'c'], lambda x: x.upper()) 'C' \"\"\" return sorted(lst, key=lambda"}
{"task_id":"task/67","completion":"\n\nmax_index = 0\n\nmax_value = lst[0]\n\nfor i in range(1, len(lst)):\n\nif fn(lst[i], lst[max_index]):\n\nmax_index = i\n\nmax_value = lst[i]\n"}
{"task_id":"task/67","completion":" \"\"\" return max(lst, key=fn) \"\"\" return max(lst, key=lambda x: fn(x))\n\ndef _max_by(lst, keyfn): \"\"\" return max(lst, key=keyfn) \"\"\" return max(lst, key=keyfn)\n\ndef _min"}
{"task_id":"task/67","completion":"\n\nreturn sorted(lst, key=fn)\n\nmax_by = property(max_by)\n\n\ndef min_by(lst, fn):\n\nreturn sorted(lst, key=fn)[::-1]\n\nmin_by = property(min_by)\n\n\ndef avg_by"}
{"task_id":"task/67","completion":" \"\"\" return the maximum element in a list by the given key \"\"\" return max(lst, key=fn) def average(lst): \"\"\" return the average of a list \"\"\" return sum(lst) / len(lst)\n\nIf you do not know what the arguments of a function are, you can find them out by"}
{"task_id":"task/68","completion":"\n\n\"\"\"Return the index of the first smallest element in the array, or None if the array is empty.\"\"\"\n\nmin_value = float('inf')\n\ni = 0\n\nwhile i < len(arr):\n\nif arr[i] < min_value:\n\nmin_value = arr[i]"}
{"task_id":"task/68","completion":"\n\n\"\"\"\n\n\u6c42min_element_index\u51fd\u6570\n\n\"\"\"\n\nimport operator\n\n\n\ndef visit(arr, i):\n\nif i < 0:\n\nreturn -1\n\nif arr[i] == min_element(arr):\n\nreturn i\n\nreturn visit(arr"}
{"task_id":"task/68","completion":"\n\n\"\"\"Returns the index of the first element in arr which is less than or equal to all other elements.\n\n>>> a = [-1, -2, -3, 0, 1, 2, 3]\n\n>>> min_element_index(a)\n\n2\n\n>>> min_element_index(a,"}
{"task_id":"task/68","completion":" \"\"\" >>> min_element_index([1, 4, 6, 5, 3, 2]) 2 >>> min_element_index([1, 4, 6, 5, 3, 2, 1]) 1 \"\"\" if len(arr) < 2: return None return arr[min(0, len(arr) - 1)]\n\n"}
{"task_id":"task/68","completion":"\n\nreturn min(arr, key=arr.__getitem__)\n\nreturn [(i,j) for i,j in zip(min_element_index(A), min_element_index(B))]\n\nN.B. This version is definitely not optimal, but I leave it as an exercise for the"}
{"task_id":"task/69","completion":"\n\nif val is None:\n\nval = [i for i in range(w)]\n\nw, h = int(w), int(h)\n\narr = np.zeros((w, h, 3), dtype=np.uint8)\n\n# The first 2 dimensions are for width and height."}
{"task_id":"task/69","completion":"\n\nif val is None:\n\nval = [random.randint(0,255) for i in range(w*h)]\n\nwidth = w\n\nheight = h\n\nl = []\n\nfor y in range(height):\n\nfor x in range(width):\n\nif val is not None"}
{"task_id":"task/69","completion":"\n\n\"\"\"Initialize 2D list of values.\"\"\"\n\nif val is None:\n\nval = np.random.randn(w, h)\n\nlst = np.zeros((w, h), dtype = np.float64)\n\nfor x in range(w):\n\nfor y in"}
{"task_id":"task/69","completion":"\n\nif val is None:\n\nval = [0 for i in range(w)]\n\nreturn [val]\n\ndef create_2d_list(w, h, val = None):\n\nif val is None:\n\nval = [0 for i in range(w)]\n\nreturn val\n\n"}
{"task_id":"task/69","completion":"\n\n\"\"\"This is the same as `initialize_2d_list` but it takes two arguments\n\ninstead of four. Note that ``w`` and ``h`` must be odd numbers\n\nwith a common factor.\n\nArgs:\n\nw: The width of the image.\n\nh: The height of the"}
{"task_id":"task/70","completion":" if d: return [x.upper() for x in d.items()] else: return []\n\n\nNow that we have the data in a format we can use, we can formulate the query. I start with the phrase that was in the request:\n\n\nfor term in query_string.split('+'): query_word"}
{"task_id":"task/70","completion":" return [d.pop(0) for d in d.items()]\n\nWow, that looks like a good candidate for a Python implementation of a Lisp loop. It looks like a for loop with a function call for an expression.\n\nWe can certainly emulate this in Python with a for loop, but we can do better. Let"}
{"task_id":"task/70","completion":" return [x for x in d.values() if x is not None] # list with non-None values def to_dictionary(v): return dict([(x, y) for x, y in v.items()]) # dict with (x, y) items # test cases assert to_dictionary([(1,"}
{"task_id":"task/70","completion":" return d.items() lst = [] lst.append(D['MARC']) lst.append(D['BIBLIO']) lst.append(D['MASTER']) for d in dict_to_list(dic): for r in d: if r.startswith('00'):"}
{"task_id":"task/70","completion":"\n\nreturn [{k: v} for k, v in d.items()]\n\n\nclass P(collections.Hashable):\n\ndef __init__(self, *args):\n\nself.data = args\n\n\nclass D(collections.Hashable):\n\ndef __init__(self, *"}
{"task_id":"task/71","completion":"\n\nreturn sum(args) / len(args)\n\nprint(average(3, 4, 5))\n\nprint(average([4, 5, 6], [7, 8, 9], [10, 11, 12]))\n\n$ python average.py\n\n6.0\n\n6.5\n\n"}
{"task_id":"task/71","completion":" #print \"The average is\", sum(args)/len(args)\n\ndef main(): average(1,2,3)\n\naverage(5,2,3)\n\naverage(5,2,3,1,4,1,5)\n\naverage(5,2,3,1,4,"}
{"task_id":"task/71","completion":" total = 0.0 for n in args: total += n return total / len(args) def median(args): total = 0.0 for n in args: total += n return total / 2.0 def print_median(args): for n in args: print(n, end=' ') print(median("}
{"task_id":"task/71","completion":" \"\"\"Return the average of the arguments\"\"\" return sum(args) / len(args) def format(s): \"\"\"Return a string representation of the argument\"\"\" return \"the value is {}\".format(s) def min(*args): \"\"\"Return the minimum of the arguments\"\"\" return args[0] def max(*args): \"\"\"Return the maximum"}
{"task_id":"task/71","completion":" def avg(*args): return sum(args) / len(args) return avg\n\nSomehow, this code (with avg() and average() defined in terms of each other) is broken. But, it works. Here's a proof.\n\n>>> x = [1, 2, 3] >>> avg(x) 2."}
{"task_id":"task/72","completion":" # Return a tuple containing intersecting elements from both sequences if len(a) != len(b): return [] return a[i] for i in range(len(b)): if a[i] == b[i]: yield a[i]\n\n\nWhen we call intersection with two sequences a and b, it returns a sequence"}
{"task_id":"task/72","completion":"\n\n\"\"\"\n\nReturn the intersection of two sets as a new set.\n\n\"\"\"\n\nc = []\n\nfor x in a:\n\nif x in b:\n\nc.append(x)\n\nreturn Set(c)\n\n# ##############################################################################\n\n# Functions: Searching\n"}
{"task_id":"task/72","completion":" - n = len(a) - m = len(b) - for i in range(n): - if a[i] == b[i]: - return False - return True - -class Test_intersection: - - def test_intersection_same_length(self): - a = [(1,2), ("}
{"task_id":"task/72","completion":" return a&b # trace class: trace(start, end, mask) # start and end are uint32s (why?) # mask is a 1b uint32 class trace(object): def __init__(self, start, end, mask): self.start = start self.end = end self.mask = mask def __"}
{"task_id":"task/72","completion":" return a.intersects(b) or b.intersects(a) #intersection - intersect a and b, keeping first intersection if there is one def intersect_keep(a, b): if a.intersects(b): return a elif b.intersects(a): return b else: return None"}
{"task_id":"task/73","completion":"\n\na = list(a)\n\nb = list(b)\n\nreturn sum(abs(a[i] - b[i]))\n\ndef hamming_distance_matrix(A, B):\n\n\"\"\"Compute the Hamming distance matrix.\n\nA and B are both m x n mat"}
{"task_id":"task/73","completion":" + import string + return string.hamming_distance(a, b) + +def hanning_window(a, length): + import scipy.signal + h = scipy.signal.hanning(length) + han = h.real + hac = h.imag + return han"}
{"task_id":"task/73","completion":"\n\ntotal = 0\n\nfor i in range(len(a)):\n\nif a[i] != b[i]:\n\ntotal += 1\n\nreturn total\n\n\ndef hamming_distance_with_power(a, b, p):\n\ntotal = 0\n\nfor i in range(len("}
{"task_id":"task/73","completion":" \"\"\"Compute the Hamming distance between two strings. >>> hamming_distance('spam', 'spam') # unique characters 2 >>> hamming_distance('spam', 'scam') # equal characters 0 >>> hamming_distance('spam', 'sapm') # equal and unique characters 2 >>> hamming_distance"}
{"task_id":"task/73","completion":"\n\nif a == b:\n\nreturn 0\n\nelif a < b:\n\nreturn 1\n\nelif a > b:\n\nreturn -1\n\nelse:\n\nreturn hamming_distance(b, a)\n\n\n\ndef compute_lsa(data):\n\nx = [0]"}
{"task_id":"task/74","completion":" # check n for integer-ness if n.isdigit(): return n def main(): # input: str input_num = int(raw_input('Enter a number: ')) # output: str output_num = '' if input_num < 0: output_num = str(input_num) + 'is not a"}
{"task_id":"task/74","completion":"\n\n# -*- coding: utf-8 -*-\n\n# \u6570\u5b57\u3092\u30c7\u30b8\u30bf\u30eb\u5316\u3059\u308b\u95a2\u6570\n\ndef formto_b(n):\n\nreturn \u201c{}.{}\u201d.format(n, 10)\n\ndef formto_"}
{"task_id":"task/74","completion":" return n.digits if __name__ == '__main__': digitize(1234567)\n\nThis looks OK, but there are a few things to note:\n\nIf you are referencing the digits in a string, you must first import the string module. Otherwise, you get a NameError: name 'digits'"}
{"task_id":"task/74","completion":"\n\n\"\"\"Digitize n according to the scheme in the comment below.\"\"\"\n\nn = abs(n)\n\nif n <= 9:\n\nreturn chr(n)\n\nresult = []\n\n# Base 10 to base 36, one digit per line.\n\nfor base in range(0, 36,"}
{"task_id":"task/74","completion":" if n == 0: return 0 if n < 0: return -1 if n == 1: return 1 else: return sum(digitize(n-1) + digitize(n-2)) number = 10.0 number.digitize()\n\nwhich will return\n\n1 0 0 0 0 0 0 0 0 0 0"}
{"task_id":"task/75","completion":" \"\"\"Arbitrary function for rolling arbitrary lists.\"\"\" return [x for x in lst + [x + offset] if x % 2 == 0] # Test the function. for lst in [ [1, 2, 3], [4, 5, 6], [7, 8, 9], [1, 1, 1],"}
{"task_id":"task/75","completion":"\n\nfor k in lst:\n\nif k < offset:\n\nlst.remove(k)\n\nlst.insert(offset, k)\n\nreturn lst\n\n\n\ndef sum(x, offset):\n\nlst = x.copy()\n\nlst.sort()\n\nfor i"}
{"task_id":"task/75","completion":"\n\nif lst.count(x) != 0:\n\nreturn [x, lst[offset:]]\n\nreturn [lst[offset], lst[:offset]]\n\n#\n\n#\n\n#\n\n#\n\n#\n\n#\n\n#\n\n#\n\n#\n\n#"}
{"task_id":"task/75","completion":" # roll a list of numbers left or right once return lst + [lst[i]+offset for i in range(len(lst)-1)] def main(): # create an array of numbers and print it out numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9] print numbers #"}
{"task_id":"task/75","completion":"\n\nlst.append(lst[offset])\n\ndef random(start, end):\n\nwhile start >= end:\n\nstart += 1\n\nyield start\n\ndef orderer(items):\n\nif len(items) > 1:\n\nvals = []\n\nfor i in range(len"}
{"task_id":"task/76","completion":"\n\ndef outfn(outlist):\n\nfor x in lst:\n\noutlist.append(fn(x))\n\nreturn outlist\n\nreturn outfn\n\nI haven't actually used this in a real program, but it seems to work just fine. I'm not sure that the performance is any different from"}
{"task_id":"task/76","completion":"\n\nfor x in lst:\n\nif fn(x):\n\nreturn True\n\nreturn False\n\n\n\ndef get_n(n):\n\nfor x in range(1, n + 1):\n\nif x * x == n:\n\nreturn x\n\n\n\nif __name__ == '__main"}
{"task_id":"task/76","completion":" if type(lst) is list: return [fn(x) for x in lst] else: return lst def square(x): return x * x def naive_power(x, n): return x ** n def log(x): return math.log(x) def root(x, n): return math."}
{"task_id":"task/76","completion":" return lst.filter(fn) def abs(x): return abs(x) if __name__ == '__main__': def main(): x = [1, -2, 4, -3, -5] print(x) print(list(map(abs, x))) print(list(some(x, abs"}
{"task_id":"task/76","completion":" return some(lst, lambda x: fn(x)) def all(lst, fn = lambda x: x): return all(lst, lambda x: fn(x)) def first(lst, fn = lambda x: x): return first(lst, lambda x: fn(x)) def second(lst"}
{"task_id":"task/77","completion":"\n\n\"\"\"Combine multiple dictionaries into one dictionary.\"\"\"\n\ncombined = defaultdict(list)\n\nfor i, d in enumerate(dicts):\n\ncombined[i].extend(d)\n\nreturn combined\n\ndef main():\n\n\"\"\"Print usage message.\"\"\"\n\nusage = '"}
{"task_id":"task/77","completion":"\n\n\"\"\"\n\nReturn a dict whose keys are all the keys in dicts and values are the\n\ncorresponding values in dicts.\n\n\"\"\"\n\ncombined = {}\n\nfor d in dicts:\n\ncombined[d[key]] = d[value]\n\nreturn combined\n\nif __"}
{"task_id":"task/77","completion":"\n\n\"\"\"Return a dictionary combining values from each of the given dictionaries.\n\nIf a key is in any of the given dictionaries, the value from that dictionary\n\nis returned. Otherwise a new value is generated using the given generators.\n\n\"\"\"\n\nreturn defaultdict(combine_function(getattr(v,"}
{"task_id":"task/77","completion":"\n\nvalues = defaultdict(list)\n\nfor d in dicts:\n\nfor k, v in d.items():\n\nif k not in values:\n\nvalues[k] = []\n\nvalues[k].append(v)\n\nreturn values\n\ndef combine_encodings(*encodings"}
{"task_id":"task/77","completion":"\n\n\"\"\"\n\nTransforms a list of dictionaries into a single dictionary with\n\nthe same key-value pairs.\n\n\"\"\"\n\nreturn defaultdict(lambda: 0, *dicts)\n\ndef is_in_all(*dicts):\n\n\"\"\"\n\nChecks if value is in all of the given"}
{"task_id":"task/78","completion":"\n\nif not lst:\n\nreturn []\n\nfor x in lst:\n\nif isinstance(x, list):\n\nreturn [flatten(x)]\n\nreturn x\n\n\n\ndef _calc_max(lst):\n\nmaxx = None\n\nfor x in lst:\n"}
{"task_id":"task/78","completion":"\n\nif not lst:\n\nreturn []\n\nelse:\n\nreturn [x for x in lst if x]\n\n# example usage\n\n>>> print(flatten([1,2,[3,4],5]))\n\n[1, 2, 3, 4, 5]\n\n\"\"\"\n"}
{"task_id":"task/78","completion":" \"\"\" Flatten a list of lists, into a list of the same items \"\"\" # print('flattening', lst) if not lst: return [] lst.append(lst[0]) for x in lst[1:]: lst.append(x) return lst def print_row(col): \"\"\""}
{"task_id":"task/78","completion":"\n\nreturn reduce(lambda x, y: x+y, lst, [] )\n\nIf we store all the maps in a list, then we can call flatten() on that list, and it will return the sum of all the maps:\n\n>>> flatten([[1,2], [3,4]])"}
{"task_id":"task/78","completion":"\n\nreturn reduce(lambda a,b: a+b, lst)\n\nlst = [1,2,3,4,5,6,7,8,9,10]\n\nprint(flatten(lst))\n\n\nThis is how the program works. First, the lst list is assigned"}
{"task_id":"task/79","completion":"\n\nreturn a - set(b) if fn(a, b) else b - set(a)\n\n\n\n#Tests:\n\ndef test_set_symmetric_difference_by(self):\n\na = set(['a', 'b', 'c', 'd', 'e', '"}
{"task_id":"task/79","completion":"\n\n\"\"\"\n\nn the set of all finite sequences of elements from `A` and `B`\n\nsorted by length.\n\n\"\"\"\n\nsorted_a = sorted(a)\n\nsorted_b = sorted(b)\n\nsorted_difference = [ x for x in sorted_a"}
{"task_id":"task/79","completion":"\n\nreturn lambda c: (a[c] if c in a else b[c] if c in b else c)\n\nself.__invariants.add(symmetric_difference_by(self.__invariants))\n\n\"\"\"\n\ndef __ne__ ( self , other ):\n\n"}
{"task_id":"task/79","completion":"\n\n\"\"\"Compute the symmetric difference of a and b and apply function fn.\n\nArgs:\n\na: A set\n\nb: A set\n\nfn: A function to apply to each element in the output.\n\nReturns:\n\nA set.\n\n\"\"\"\n\nreturn set (a | b)"}
{"task_id":"task/79","completion":"\n\nreturn fn(a, b) | fn(b, a)\n\ndef symmetric_difference(a, b):\n\nreturn not a & b\n\ndef antisymmetric_difference(a, b):\n\nreturn a | b & b\n\ndef set_difference(a, b"}
{"task_id":"task/80","completion":"\n\n\"\"\"Find the index of the last occurrence of value in the list\"\"\"\n\nindex = -1\n\nfound = False\n\nfor i in range(len(lst)):\n\nif fn(lst[i]):\n\nfound = True\n\nindex = i\n\nbreak\n\nif not found:"}
{"task_id":"task/80","completion":"\n\n\"\"\"\n\niterable: list or tuple\n\nfn: function\n\n\"\"\"\n\nindex = 0\n\nfor item in lst:\n\nif fn(item):\n\nindex = index + 1\n\nreturn index\n\ndef find_last_index_if(lst, fn):\n\n\"\"\"\n"}
{"task_id":"task/80","completion":" # List comprehension can use \u201c_\u201d to ignore values. return max(0, len(lst) - len(lst) - fn(lst[-1]))\n\nAnd finally, the main program will use all of the above functions to find the last index of a particular string in a list of strings."}
{"task_id":"task/80","completion":"\n\nlast_index = None\n\nfor i in range(len(lst)):\n\nif fn(lst[i]):\n\nlast_index = i\n\nreturn last_index\n\n\ndef do_comparison(fn, lst):\n\nindex = find_last_index(lst"}
{"task_id":"task/80","completion":" # Find the last index of item in the list. # Base case. if lst == []: return None # Recursive case. return find_last_index(lst[1:], fn)\n\nHere is the Python code:\n\ndef find_last_index(lst, fn): # Find the last index"}
{"task_id":"task/81","completion":"\n\ntotal = 0\n\nfor num in nums:\n\ntotal += num * weights[num]\n\nreturn total / weights.sum()\n\ndef example_3():\n\n# get a list of numbers from user\n\nnumber_list = [float(num) for num in input(\"Enter some numbers separated by"}
{"task_id":"task/81","completion":" '''Calculate the weighted average of the values in nums, weighted by the weights in weights. Uses the same formula as np.mean, but is faster for larger arrays because it doesn't require making a copy of the array. ''' return np.sum(nums * weights, axis=0) / weights.sum()"}
{"task_id":"task/81","completion":" return sum(nums) / weights\n\nTo do:\n\nExtend to multidimensional arrays\n\n10. Data Analysis - Linear Regression\n\nSome problems in data analysis can be best solved using linear regression. Linear regression is used to fit a line to a set of data.\n\nThe concept of a line of best"}
{"task_id":"task/81","completion":" return nums / weights.sum() def standard_deviation(nums): return math.sqrt(sum(x**2 for x in nums)) def plot_data(nums, weights): plt.plot(nums, weights, 'bo', linewidth=2, label='measured') plt"}
{"task_id":"task/81","completion":" return sum(nums) / sum(weights) mylist = [8, 3, 12, 9, 0, 1, 5, 4, 6, 0, 4, 9, 1, 0, 5, 9, 6, 5, 0, 1, 2, 3, 5, 9, 0, 1, 5, 9"}
{"task_id":"task/82","completion":"\n\n\"\"\"\n\nReturn a new list containing all elements of lst\n\nthat pass the test defined by filter.\n\n\"\"\"\n\nreturn list(filter(lambda x: x in lst, lst))\n\n\ndef main():\n\nargs = sys.argv[1:]\n\nlst = list(args"}
{"task_id":"task/82","completion":"\n\nif filter(lst[0]):\n\nreturn lst[0], bifurcate(lst[1:], filter)\n\nreturn lst[0], None\n\n\nThis function splits a list into two new lists, by recursively splitting the head of the list until the filter criteria is met"}
{"task_id":"task/82","completion":"\n\n\"\"\"Bifurcate list into a list of elements for which the filter returns True\n\nand a list of elements for which the filter returns False\"\"\"\n\nresult = []\n\nfor elt in lst:\n\nif filter(elt):\n\nresult.append(elt)\n\nelse:\n\nresult"}
{"task_id":"task/82","completion":"\n\n\"\"\"Bifurcate a list of lists into two lists of the same size\n\nReturn two lists of the same size as the input list, where the\n\ninput list is a list of lists.\n\nEach list in the input list will appear as a list in the two\n\noutput lists.\n\n>>> l"}
{"task_id":"task/82","completion":"\n\n# Checks if lst contains items in filter\n\nif filter is None:\n\n# filter can be None when calling from list comprehension\n\nfilter = set()\n\nfor i in lst:\n\nif i in filter:\n\n# item is in filter\n\nlst.remove(i)\n\nreturn"}
{"task_id":"task/83","completion":"\n\n\"\"\"a test that returns True when all items in a list are equal.\"\"\"\n\nfor item in lst:\n\nif item != lst[0]:\n\nreturn False\n\nreturn True\n\n\ndef not_equal(lst):\n\n\"\"\"a test that returns True when all items in a list are not"}
{"task_id":"task/83","completion":"\n\nif type(lst) is not list:\n\nreturn False\n\nfor x in lst:\n\nif x != lst[0]:\n\nreturn False\n\nreturn True\n\ndef add_items(lst1, lst2):\n\nfor x in lst1:\n\nlst"}
{"task_id":"task/83","completion":" ''' Ensures that two lists are the same length and all elements are equal. ''' for i in range(len(lst)): if not lst[i] == lst[i]: return False return True\n\nThis function checks that two lists are the same length and that all elements are equal. Because we write it"}
{"task_id":"task/83","completion":" for i in lst: if i != lst[0]: return False return True def main(): lst = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] print(all_equal(lst)) if __name__ == '__main__': main()\n\nDownload the"}
{"task_id":"task/83","completion":"\n\nfor i in lst:\n\nfor j in lst:\n\nif i != j:\n\nreturn False\n\nreturn True\n\ndef print_array(arr):\n\nfor i in arr:\n\nprint i\n\nprint\n\ndef count_unique(arr):\n\ncnt = 0\n"}
{"task_id":"task/84","completion":"\n\n\"\"\"Return the difference of a and b.\n\n\n\n>>> from sympy import Symbol, difference\n\n>>> x, y = Symbol('x y'), Symbol('x')\n\n>>> difference(x, y)\n\nx - y\n\n>>> difference(x, x)\n\n0\n\n>>> difference(x"}
{"task_id":"task/84","completion":"\n\nreturn a - b\n\n\nHere, the function difference( ) defines a function difference( ) that accepts two values and returns the difference of the two values. The function difference( ) is called a \u201cmethod.\u201d To call the method difference( ), you use the syntax:\n\nresult = methodname(arg1,"}
{"task_id":"task/84","completion":" return a-b\n\n#!/usr/bin/env python3 class Point: def __init__(self, x, y): self.x = x self.y = y def move(self, dx, dy): self.x += dx self.y += dy if __name__ == '__main__': p1"}
{"task_id":"task/84","completion":" return a - b def add(a, b): return a + b # \u521b\u5efa\u6570\u7ec4 def createArray(n): return [0] * n # \u521b\u5efa\u7ed3\u6784\u4f53 def createStruct(n): return { 'f1': 0, 'f"}
{"task_id":"task/84","completion":" return a - b def factorial(n): if n == 0: return 1 else: return n * factorial(n-1) def fibonacci(n): if n == 0: return 0 elif n == 1: return 1 else: return fibonacci(n-1) + fibonacci(n-2"}
{"task_id":"task/85","completion":"\n\nreturn sub(r'(?:[{}])|(?:[^$\\w()\\[\\]\\-.!\\\\/]*$)|(?:[^\\u0000-\\u001F\\u007F]*[\\u007F-\\u0000])', r'\\u%04"}
{"task_id":"task/85","completion":"\n\nreturn re.sub(r'(\\w+[-+])', lambda match: int(match.group(1)), s)\n\n#json.dumps(s, ensure_ascii=False)\n\ns = '\"foo\":'\n\nprint kebab(s)\n\n9. Comp"}
{"task_id":"task/85","completion":"\n\nreturn s.replace(\u2018_\u2019, \u2018-\u2018).lower()\n\ndef main():\n\nparser = argparse.ArgumentParser()\n\nparser.add_argument(\u2018-o\u2019, dest=\u2019output\u2019,\n\nhelp=\u2019output file\u2019"}
{"task_id":"task/85","completion":"\n\nreturn s.replace(' ', '_')\n\nfor line in sub('^#.*$', '').split('\n\n'):\n\nline = line.strip()\n\nif len(line) > 0:\n\nprint line\n\n_b = kebab(line)\n\nif line.start"}
{"task_id":"task/85","completion":"\n\nreturn s.encode('utf-8')[::-1]\n\ndef unmangle(s):\n\nreturn s.decode('utf-8')[::-1]\n\ndef correct_encoding(s):\n\ns = s.encode('utf-8')\n\nfor i in"}
{"task_id":"task/86","completion":" return miles * 1.609344 print miles_to_km(miles)\n\nThe previous example will not work! The reason is that the interpreter considers the statement a syntax error, so it raises a SyntaxError exception. It is important to understand that there is no way to catch this exception with a try/except block,"}
{"task_id":"task/86","completion":" return miles * 1.609344 def main(): print miles_to_km(3) if __name__ == '__main__': main()\n\nThis code is written to be compliant with both Python 2 and Python 3, so you can use Python 2 or Python 3 to run it, but the answer it gives is different in"}
{"task_id":"task/86","completion":" return miles * 1.609344 return miles_to_km\n\nNext, we\u2019ll create a new variable miles_to_km that calls miles_to_km() . We\u2019ll also create a new variable called miles_to_meters . We\u2019ll use miles_to_meters to store"}
{"task_id":"task/86","completion":" return miles / 1.609344 def gallons_to_l(gallons): return gallons / 3.785411 def add_gal_to_km(gallons, km): return gallons / 3.785411 * km def km_to_gallons(km): return (km / 1.609344)"}
{"task_id":"task/86","completion":" return miles * 1.609344 def main(): miles = input(\"Enter miles: \") km = miles_to_km(miles) print(\"miles = %s km\n\n\" % km) if __name__ == \"__main__\": main()\n\nOutput:\n\n$ python main.py Enter miles"}
{"task_id":"task/87","completion":"\n\nend = int(end)\n\nresult = 1\n\nwhile end >= start:\n\nresult *= power\n\nend -= 1\n\nreturn result\n\n# the output for the last two calls is:\n\n# In [7]: c = Power.sum_of_powers(4)\n\n# In"}
{"task_id":"task/87","completion":"\n\nreturn sum([pow(start, end - 1, power) for power in range(power)])\n\n\n\ndef show_powers(end, start = 1, power = 2):\n\nreturn '{}: {}'.format(start, sum_of_powers(end, power, start))\n\n\n\nprint"}
{"task_id":"task/87","completion":" end = end - 1 if end < 0: end = 0 if power == 1: return sum(x**(end-start)) else: return sum(x**power*sum_of_powers(end-start, power-1, start))\n\n>>> from math import pow >>> timeit sum_of_powers(10"}
{"task_id":"task/87","completion":"\n\ntotal = 0\n\nwhile power <= end:\n\ntotal += start\n\ntotal *= power\n\npower += 1\n\nreturn total\n\nif __name__ == '__main__':\n\nprint(sum_of_powers(10, 3))\n\nprint(sum_of_powers(10,"}
{"task_id":"task/87","completion":"\n\n\"\"\"\n\nEnd must be >= start\n\n\"\"\"\n\ndef power_of_2(n):\n\nreturn 2**n\n\nif end <= start:\n\nreturn [end, start]\n\nreturn [end - power_of_2(start) + 1, start]\n\nfor x in range"}
{"task_id":"task/88","completion":"\n\n\"\"\"\n\nReturn a function that composes any number of other functions.\n\n\"\"\"\n\nreturn reduce(lambda f, g: lambda x: f(g(x)), fns)\n\ndef curry(fn, *args, **kwargs):\n\n\"\"\"\n\nCurry a function by applying it to arguments"}
{"task_id":"task/88","completion":"\n\n\"Returns a function that represents the application of all the\n\n*fns. For example, compose(f, g, h)(x) is equivalent to f(g(h(x))).\"\n\nreturn reduce(lambda f, g: f(g), fns)\n\n// This can be done in pure"}
{"task_id":"task/88","completion":"\n\nr = reduce(lambda x, y: x(y), fns)\n\nreturn lambda x: r(x)\n\nf = lambda x: x+1\n\ng = lambda x: x**2\n\nprint(compose(f, g))\n\n>>> print(compose(f, g"}
{"task_id":"task/88","completion":"\n\nreturn reduce(lambda f, g: lambda x: f(g(x)), fns, lambda x: x)\n\nThen, you can use @compose to define a new inner function that calls the given functions and returns the result:\n\n>>> def double(x):\n\n... return x * 2\n\n"}
{"task_id":"task/88","completion":"\n\nreturn reduce(lambda f, g: lambda x: f(g(x)), fns, lambda x: x)\n\nexample = functools.partial(compose, lambda x:x+2, lambda x:x+3)\n\nexample(1) # returns 6\n\nThe partial function is defined"}
{"task_id":"task/89","completion":"\n\nif len(a) != len(b):\n\nreturn 0\n\nfor i in range(len(a)):\n\nif a[i] != b[i]:\n\nreturn 0\n\nreturn 1\n\ndef delta(a, b):\n\nif similarity(a, b) == 1:\n"}
{"task_id":"task/89","completion":"\n\nreturn a.lower() == b.lower()\n\n\nif any(contains(person, name) for name in [\n\n'Tom', 'B', 'J', 'G', 'Alice'\n\n]):\n\n# ...\n\n2.2.1.2.2.2.4.3"}
{"task_id":"task/89","completion":"\n\nreturn a.lower() == b.lower()\n\ndef get_adjectives(html):\n\n# get the adverbs\n\nadverbs = [\n\nadverb.strip()\n\nfor adverb in\n\n(n.strip() for n in\n\nhtml.replace(\"<\", \"<\").replace"}
{"task_id":"task/89","completion":"\n\n# get the results of the analogical task\n\nret = a.analogical_results()\n\n# check if the two datasets are identical\n\nif ret is not None:\n\n# get the analogical task results\n\nar = b.analogical_results()\n\n# check if they are identical"}
{"task_id":"task/89","completion":"\n\n\"\"\"Return similarity of two strings.\"\"\"\n\n# The default is to return a float in the range [0, 1].\n\n#\n\n# https://en.wikipedia.org/wiki/Cosine_similarity\n\nreturn np.dot(a, b) / (np.linalg.norm("}
{"task_id":"task/90","completion":"\n\n'''\n\nCheck if two strings have the same contents.\n\n'''\n\nfor i in range(len(a)):\n\nif a[i] != b[i]:\n\nreturn False\n\nreturn True\n\ndef have_same_order(a, b):\n\n'''\n\n"}
{"task_id":"task/90","completion":"\n\na.contents == b.contents\n\ndef have_same_url(a, b):\n\na.url == b.url\n\ndef have_same_version(a, b):\n\na.version == b.version\n\ndef are_diffs_acceptable(a, b):\n"}
{"task_id":"task/90","completion":"\n\n- \"\"\"\n\n- Checks if the content of a file is the same as another file.\n\n-\n\n- This checks the content of a file a is the same as another file b\n\n-\n\n- :type a: string\n\n- :type b: string\n\n- :rtype: bool\n"}
{"task_id":"task/90","completion":"\n\n+ r = open(a).read()\n\n+ s = open(b).read()\n\n+ return r == s\n\n+ def check_whitespace(a, b):\n\n+ assert a.strip() == b.strip()\n\n+ def test_check_whitespace(self):"}
{"task_id":"task/90","completion":"\n\nreturn a.content == b.content\n\n>>> have_same_contents(file_a, file_b)\n\nTrue\n\n>>> have_same_contents(file_a, file_b)\n\nFalse\n\n>>> have_same_contents(file_a, file_b)"}
{"task_id":"task/91","completion":"\n\ndays = n.days\n\nif days < 0:\n\nraise ValueError('Days cannot be negative: %d' % days)\n\nelse:\n\nreturn timedelta(days=days)\n\ndef days_from_date(date):\n\nreturn days_from_now(date.days)\n"}
{"task_id":"task/91","completion":"\n\ndays = timedelta(days=n)\n\ny = days.days\n\nm = days.days * 365 + days.month\n\nd = days.days * 30 + days.days\n\nreturn date(y, m, d)\n\ndef days_to_now(n):\n\ndays ="}
{"task_id":"task/91","completion":"\n\n\"\"\" A function to return the number of days until now plus the given number of days \"\"\"\n\nreturn timedelta(days=n) - date.today()\n\ndef days_from_date(date):\n\n\"\"\" A function to return the number of days until a given date \"\"\"\n\nreturn days_from_now"}
{"task_id":"task/91","completion":"\n\nreturn timedelta(days=n)\n\ndef days_to_now(n):\n\nreturn timedelta(days=-n)\n\ndef days_to_year(n):\n\nreturn timedelta(days=-n/365)\n\ndef days_to_month(n):\n\nreturn timedelta"}
{"task_id":"task/91","completion":"\n\nif n == 0:\n\nreturn date.today()\n\nd = timedelta(days=n)\n\ndays = d.days + timedelta(days=1)\n\nreturn date(year=d.year, month=d.month, day=d.day, hour=d.hour,\n"}
{"task_id":"task/92","completion":"\n\nif isinstance(val, int):\n\nreturn val\n\nelif isinstance(val, float):\n\nreturn val\n\nelif isinstance(val, list):\n\nfor n in range(len(val)):\n\nval[n] = cast_list(val[n])\n\nreturn"}
{"task_id":"task/92","completion":" + \"\"\" + Uncast val into a list + \"\"\" + val = val.strip() + if len(val) == 0: + return None + elif len(val) == 1: + return val + else: + parts = val.split('_') + parts = [int(part) for part in parts] + return"}
{"task_id":"task/92","completion":"\n\nreturn [int(i) for i in val.split()]\n\ndef get_primes(number, list=range(2, number+1)):\n\nif number in list:\n\nreturn list\n\nnew_list = []\n\nwhile number > 1:\n\nif number % 2 == 0"}
{"task_id":"task/92","completion":"\n\nreturn [val]\n\ndef show_cast_list(val):\n\nprint val\n\n\ndef describe_types(val):\n\nprint 'type: ' + type(val)\n\nprint 'value: ' + str(val)\n\n\ndef describe_sequence(val):\n\nprint 'length: '"}
{"task_id":"task/92","completion":"\n\nif type(val) == str:\n\nif val == 'true':\n\nreturn True\n\nif val == 'false':\n\nreturn False\n\nif val == 'null':\n\nreturn None\n\nif val == 'None':\n\nreturn None\n\nif val == '[]':\n\nreturn list"}
{"task_id":"task/93","completion":"\n\n\n\nif reverse:\n\nd = {v: k for k, v in d.items()}\n\nelse:\n\nd = {v: k for k, v in d.items()}\n\nreturn d\n\n\n\ndef sort_dict_by_key(d, reverse = False):\n\n\n"}
{"task_id":"task/93","completion":"\n\n\"\"\"\n\nReturn a sorted dict and its reverse sorted copy, both\n\nhaving values in the `d` dict in sorted order.\n\n\n\nArguments:\n\nd: dict to sort\n\nreverse: boolean (default: False)\n\n\"\"\"\n\nif not isinstance(d, dict):\n\nraise"}
{"task_id":"task/93","completion":" \"\"\"A sort_dict helper function.\"\"\" if not isinstance(d, dict): raise TypeError('d must be a dict') if reverse: sorted(d.items(), key=lambda t: t[1], reverse=True) else: sorted(d.items(), key=lambda t: t[0], reverse=False"}
{"task_id":"task/93","completion":"\n\n\"\"\" Sort a dictionary's items by value.\n\nArguments:\n\nd -- a dictionary\n\nreverse -- True, to sort in reverse order\n\n\"\"\"\n\nif not isinstance (d, dict ):\n\nraise TypeError ( \" sort_dict_by_value() argument must be a dictionary \" )\n"}
{"task_id":"task/93","completion":" \"\"\"Sort dict by value. Arguments: d (dict) Dictionary to sort. reverse (bool) If True, sort in reverse order. \"\"\" if d: key_sort_value = {} for key, value in d.items(): if key not in key_sort_value: key_sort_value[key] = key_"}
{"task_id":"task/94","completion":"\n\nreturn re.sub(r'\\s+', '-', s.lower())\n\ndef urlsplit(url):\n\nif url.lower().startswith('http://'):\n\nreturn (url[7:], None)\n\nelif url.lower().startswith('https://"}
{"task_id":"task/94","completion":"\n\nreturn re.sub(r'[^\\w\\s]+', '-', s).lower()\n\ndef add_first_of_type(r):\n\n\"\"\"Adds a class=\"first-of-type\" to each element\"\"\"\n\nfor el in r:\n\nel.classList.add('"}
{"task_id":"task/94","completion":"\n\nreturn s.replace(' ', '-')\n\ndef get_links(url):\n\nlinks = []\n\nurl = re.sub('^https?://[^/]+\\.[^/]+$', '', url)\n\nfor i in range(0, len(url)):\n\nurl["}
{"task_id":"task/94","completion":"\n\nreturn re.sub(r\"(?u)\\b(?:[a-z0-9]+[a-z0-9]+[a-z0-9]+[a-z0-9]+|[a-z0-9]+[a-z0-9]+[a-z0-"}
{"task_id":"task/94","completion":"\n\n\"\"\"\n\nhttp://stackoverflow.com/questions/1603357/slugify-words-with-underscores\n\n\"\"\"\n\nreturn re.sub(r'[^\\w]', '-', s).strip('-').lower()\n\ndef get_parent_ids(obj"}
{"task_id":"task/95","completion":" roman = \"\" value = num if num >= 4000000: value = (num/1000000)*1000 num = value elif num >= 1000000: value = (num/1000000)*100 num = value elif num >= 10000: value = num elif num >= 1000: value = num*10 num = value elif num"}
{"task_id":"task/95","completion":" \"\"\"convert number to roman numeral\"\"\" if isinstance(num, int): return roman_numeral(num) def roman_numeral(num): \"\"\"convert number to roman numeral\"\"\" if isinstance(num, int): return roman_numeral(num) def roman_numeral("}
{"task_id":"task/95","completion":" roman = [] for numeral, power in roman_numeral_powers: roman.append(numeral * power) return ''.join(roman) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35"}
{"task_id":"task/95","completion":"\n\nif num < 0:\n\nreturn '-' + roman_numeral(num)\n\nreturn roman_numeral(num)\n\n\nThe to_roman_numeral function takes a positive integer, and returns a string of the form \"MCDLXXXIV\" for numbers in the range 0 to 3999"}
{"task_id":"task/95","completion":" roman = [] while num >= 100: num = num // 100 roman.append(num) while num >= 10: num = num // 10 roman.append(num) while num >= 1: num = num // 1 roman.append(num) return roman def main(): while True: print(to_roman_"}
{"task_id":"task/96","completion":"\n\n98 n/a with self.assertRaises(AssertionError):\n\n99 n/a fn(None, prop)\n\n100 n/a with self.assertRaises(AssertionError):\n\n101 n/a fn(None, False)\n\n102 n/a with self.assert"}
{"task_id":"task/96","completion":"\n\n# return True if fn is a function whose property prop is defined\n\ndef check_prop(fn, prop):\n\n# Return a property test function. Return True if the property is\n\n# Return a property test function. Return True if the property is\n\n# false, False otherwise.\n\n# false, False"}
{"task_id":"task/96","completion":"\n\n# For testing a function, rather than a method of a class, we\n\n# get the class object and call the method on that.\n\n# For example, here we test __len__ on a class, rather than\n\n# a built-in operation of a string.\n\nobj = fn.__self__"}
{"task_id":"task/96","completion":" return fn(lhs, prop, rhs)\n\ndef check_cond(fn, lhs, rhs, guard, eq):\n\ncond_prop = prop_of(guard)\n\nreturn cond_prop(lhs, rhs, eq)\n\ndef reorder_terms(fn, lhs,"}
{"task_id":"task/96","completion":" if prop not in fn._prop_map: fn._prop_map[prop] = callable(fn) def get_props(fn): if type(fn) == type(None): return fn._prop_map else: return fn._prop_map.copy()\n\nclass _BaseProp(object):\n\n"}
{"task_id":"task/97","completion":"\n\ncounter = 0\n\nfor v in lst:\n\nif v == val:\n\ncounter += 1\n\nreturn counter\n\n\n\ndef is_in_set(lst, val):\n\nfor v in lst:\n\nif v == val:\n\nreturn True\n\nreturn False\n\n\n\n"}
{"task_id":"task/97","completion":" # take all values in lst and count the number of times they # occur. # if the item is already in the count, then just add 1. # if it's not, then add it and count it. return lst.count(val) + lst.count(val) + 1\n\nAnd a test for this"}
{"task_id":"task/97","completion":"\n\ncounts = dict()\n\nfor e in lst:\n\nif e == val:\n\ncounts[e] = counts.get(e, 0) + 1\n\nreturn counts\n\n\n\ndef parse_config(filename):\n\n'''\n\nReads and parses a config file.\n"}
{"task_id":"task/97","completion":"\n\ncount = 0\n\nfor i in lst:\n\nif i == val:\n\ncount += 1\n\nreturn count\n\ndef remove_duplicates(lst):\n\nsorted_lst = sorted(lst)\n\nreturn sorted_lst[1:]\n\ndef get_all"}
{"task_id":"task/97","completion":" return lst.count(val) def print_counts(lst, val): for i in range(len(lst)): if lst[i] == val: print i, count_occurrences(lst, val) def print_occurrences(lst, val): for i in range("}
{"task_id":"task/98","completion":"\n\nreturn (nums.count(n) * 0.5).count(0)\n\ndef find_parity_outliers_1(nums):\n\nreturn (nums.count(n) * 0.5).count(0)\n\ndef find_parity_outliers_2"}
{"task_id":"task/98","completion":"\n\n\"\"\"Finds outliers based on the parity of a set of integers.\"\"\"\n\nc = Counter(nums)\n\nfor x in c:\n\noutliers = c.get(x, 0)\n\noutliers += x\n\noutliers -= c.get(x, 0)\n"}
{"task_id":"task/98","completion":"\n\ncount = Counter()\n\nfor i in range(nums):\n\ncount[i] += 1\n\noutliers = []\n\nfor i in range(len(count)):\n\nif count[i] > 4 * len(count) / 3:\n\noutliers.append(i)"}
{"task_id":"task/98","completion":"\n\n\"\"\"\n\nFinds the number of outlier parity samples, where outlier means \"the\n\nnumber of samples whose parity differs from the parity of the\n\nsample's majority class\" (which is a majority-vote classifier in this\n\nexample).\n\n\"\"\"\n\noutliers = 0\n\nfor i"}
{"task_id":"task/98","completion":"\n\nc = Counter(nums)\n\nc = c.drop(1)\n\ncount = c.most_common(3)\n\nprint count\n\ncount = c.most_common(4)\n\nprint count\n\ncount = c.most_common(5)\n\nprint count\n\ncount"}
{"task_id":"task/99","completion":" \"\"\"Takes a list of 2-tuples and returns a dictionary\"\"\" return {key: value for key, value in zip(keys, values)} def main(): \"\"\"The main function for the script. It calls the functions in the order listed below. \"\"\" to_dictionary([(1, 'One'), (2, 'Two'),"}
{"task_id":"task/99","completion":"\n\nreturn { k: v for k, v in zip(keys, values) }\n\n\ndef encrypt(message, key):\n\nreturn message[:16] + chr(key % 256) + message[16:]\n\n\ndef decrypt(message, key):\n\nreturn decrypt_byte(message[:16],"}
{"task_id":"task/99","completion":"\n\n\"\"\"Convert a list of keys to a dictionary.\"\"\"\n\nif isinstance(keys, str):\n\nkeys = [keys]\n\nif isinstance(values, str):\n\nvalues = [values]\n\nreturn {key: value for key, value in zip(keys, values)}\n\n\nWe are"}
{"task_id":"task/99","completion":" \"\"\"Get dictionary representation of sequence.\"\"\" dict = {} for key in keys: dict[key] = values[key] return dict def to_list(keys, values): \"\"\"Get list representation of sequence.\"\"\" return [values[key] for key in keys] def to_str(keys, values): \"\"\"Get string representation of sequence"}
{"task_id":"task/99","completion":" \"\"\"Encode a dictionary into a JSON structure in the form of a dictionary.\"\"\" if not isinstance(values, dict): values = {values} d = {} for key in keys: d[key] = values[key] return d def _decode_json(json_data): \"\"\"Decode a JSON string into a Python"}
{"task_id":"task/100","completion":"\n\n\"\"\"An iterable that yields end, start*step, start*step*step, ...\n\nuntil 2*step+1 == end.\n\n\"\"\"\n\nstep += 1\n\nend = 2*step + 1\n\nwhile step < end:\n\nyield start * step\n\nstep += step\n\n"}
{"task_id":"task/100","completion":"\n\nif step == 1:\n\nreturn [start]\n\nelif step == 2:\n\nreturn [start, start + start]\n\nelif step == 3:\n\nreturn [start, start + start + start]\n\nelif step == 4:\n\nreturn [start, start + start + start"}
{"task_id":"task/100","completion":"\n\n\"\"\"Calculate the nth term of a geometric progression\"\"\"\n\nn = int(end/step)\n\nnum = start\n\ndenom = step\n\nsum = num * step\n\nif n > 0:\n\nreturn sum + (n-1)*denom\n\nelif n == 0:"}
{"task_id":"task/100","completion":"\n\n\"\"\"\n\nCompute nth term of geometric progression.\n\n>>> geometric_progression(5, 1, 2)\n\n5\n\n>>> geometric_progression(15, 2, 3)\n\n60\n\n>>> geometric_progression(1000, 6, 4)\n\n100000\n\n>>> geometric"}
{"task_id":"task/100","completion":"\n\n\"\"\"Return successive terms of the Arithmetic Progression\n\nArithmetic Progression:\n\nhttp://en.wikipedia.org/wiki/Arithmetic_progression\n\n\"\"\"\n\nnext = start\n\nfor i in range(end):\n\nnext = next * step\n\nreturn next\n\ndef binary_search"}
{"task_id":"task/101","completion":"\n\nreturn _find_last(lst, _reverse=True, fn)\n\n\n\n# \u6839\u636e\u7d22\u5f15\u5728list\u4e2d\u627e\u51fa\u6700\u540e\u4e00\u4e2a\u5143\u7d20\n\ndef find_last(lst, n):\n\nreturn _find"}
{"task_id":"task/101","completion":"\n\n# Prevent infinite loop\n\nfound = False\n\nfor i in range(len(lst)):\n\nif fn(lst[i]):\n\nfound = True\n\nbreak\n\nif not found:\n\nreturn -1\n\nreturn lst[len(lst)-1]\n\n\n\n"}
{"task_id":"task/101","completion":"\n\n\"\"\"\n\nlst:list\n\nfn:function\n\nreturn the last item of lst for which fn(lst[-1]) is true\n\n\"\"\"\n\n# todo: return the last item of lst for which fn(lst[-1]) is true\n\nlst.sort()"}
{"task_id":"task/101","completion":"\n\nprint(\"Find last: \", end=\"\")\n\nif len(lst) > 0:\n\nresult = lst[len(lst)-1]\n\nelse:\n\nresult = None\n\nprint(result)\n\nreturn result\n\ndef sort_items(lst):\n\nsorted_"}
{"task_id":"task/101","completion":"\n\n'''Returns the last element of a list that satisfies the function and all its predecessors.\n\n'''Returns the last element of a list that satisfies the function and all its predecessors.\n\nIt might be faster to use this if you can guarantee that the list is sorted.\n\nIt might be faster to use this if you"}
{"task_id":"task/102","completion":"\n\n\"\"\"\n\nWhen given a dict, return a dict with the elements sorted by key.\n\nIf the `reverse` flag is True, the sort is reversed.\n\n>>> list(sort_dict_by_key({'a': 1, 'b': 2, 'c': 3}, reverse = True))\n\n"}
{"task_id":"task/102","completion":"\n\nif reverse:\n\nd = {val: key for key, val in d.items()}\n\nreturn d\n\n\n\ndef count_occurrences(value, d):\n\nreturn sum(1 for key, val in d.items() if key == value)\n\n\n\ndef get_min_occ"}
{"task_id":"task/102","completion":"\n\nif not reverse:\n\nd.sort(key = lambda k: k[1])\n\nelse:\n\nd.sort(key = lambda k: k[0])\n\nreturn d\n\n\ndef print_dict(d):\n\nfor k, v in d.iteritems():\n\nprint \"%s"}
{"task_id":"task/102","completion":"\n\n'''Return a new dictionary with its entries sorted by key. If\n\nreverse is True, then the entries are sorted in reverse order.\n\n>>> d = { 'one' : 1, 'two' : 2, 'three' : 3 }\n\n>>> d.sort_dict_by_key()\n\n"}
{"task_id":"task/102","completion":"\n\n\"\"\"Sort the dictionary d by key.\n\nd must be a dictionary, not a list.\n\nIn case of reverse, the result is a dictionary where the keys are\n\nsorted in reverse order.\n\n\"\"\"\n\nif type(d) != type({}):\n\nraise TypeError(\"d must be"}
{"task_id":"task/103","completion":"\n\nreturn s.split('\n\n')\n\n\n\n#!/usr/bin/env python\n\n#-*- coding: utf-8 -*-\n\nimport sys\n\nif len(sys.argv) == 1:\n\nsys.exit('python script filename')\n\nfile = sys.arg"}
{"task_id":"task/103","completion":"\n\nreturn s.split('\n\n')\n\n\n\ndef clean_lines(lines):\n\nreturn [x.rstrip() for x in lines if x.strip()]\n\n\n\ndef parse_args():\n\nparser = argparse.ArgumentParser()\n\nparser.add_argument('filename', help='"}
{"task_id":"task/103","completion":"\n\n\"\"\"Split a single line of text into a list of lines\"\"\"\n\nlines = []\n\nfor x in s.split(\"\n\n\"):\n\nlines.append(x)\n\nreturn lines\n\n\n\ndef count_occurrences(lines, pattern):\n\n\"\"\"Count the number of times a pattern occurs"}
{"task_id":"task/103","completion":"\n\nlines = s.split('\n\n')\n\nreturn lines\n\ndef parse_lines(lines):\n\nsplit_lines = lines\n\nfor i in range(0, len(split_lines)):\n\nline = split_lines[i]\n\nif line.endswith(' '):\n\n"}
{"task_id":"task/103","completion":" # Python3\n\nr = s.rstrip()\n\nfor line in r.split('\n\n'):\n\nyield line\n\ndef is_duplicate(s):\n\nprevious = None\n\nfor line in s:\n\nif line not in previous:\n\nprint(line)\n\n"}
{"task_id":"task/104","completion":"\n\nfor x in values:\n\nif x in lst:\n\nreturn True\n\nreturn False\n\n\ndef includes_all(lst, values):\n\nfor x in values:\n\nif x not in lst:\n\nreturn False\n\nreturn True\n\n\ndef is_file(name):\n\n"}
{"task_id":"task/104","completion":"\n\n\"\"\"\n\nReturn True if any of the values are contained in lst.\n\n\"\"\"\n\nfor val in values:\n\nif val in lst:\n\nreturn True\n\nreturn False\n\n\n\n# delete_any_def #\n\ndef delete_any_def(lst, values):\n\n"}
{"task_id":"task/104","completion":" include = False while lst and not include: if values.is_in(lst[0]): include = True lst.remove(lst[0]) return include def list_includes(lst, values): include = False while lst and not include: if values.is_in(lst[0]"}
{"task_id":"task/104","completion":" \"\"\" Returns true if any item in the list matches any value in the list. \"\"\" for item in lst: if item in values: return True return False >>> includes_any([1, 2, 3], [1, 2, 3]) True >>> includes_any([1, 2, 3], [1, 2, 4]) False"}
{"task_id":"task/104","completion":" # Like includes() but returns true if any value is found in # list. return (x in lst for x in values) def list_equals(lst, values): # Similar to equal() but returns true if any value is found in # list. return (x == y for x, y in zip(lst,"}
{"task_id":"task/105","completion":"\n\n\"\"\"\n\nReturn a DataFrame with the rows of each given DataFrame\n\nmerged together.\n\nIn the case of duplicate keys, the values from the columns\n\nof the left DataFrame will be used.\n\nAdditional keyword arguments are passed to pandas.DataFrame.merge.\n\nFor example,"}
{"task_id":"task/105","completion":"\n\n\"\"\"\n\nReturn a Series or DataFrame with duplicate rows removed,\n\nrow-wise.\n\nArguments:\n\n*args: A list of Series or DataFrame objects to merge\n\nReturns:\n\nA Series or DataFrame object\n\nExamples:\n\n>>> df = pd.DataFrame({\""}
{"task_id":"task/105","completion":" + \"Merge multiple fields into a single field. Fields are + specified as sequences of tuples, or lists of tuples in + case of fields with aliases. + + For example:: + + Age = Struct('age', [('name', 'name', 'name')]) + + Name = Struct('name', [('first',"}
{"task_id":"task/105","completion":"\n\nresult = list(args)\n\nfor i in range(len(result)):\n\nresult[i] = tuple(result[i])\n\nfor i in range(len(result)):\n\nresult[i] = list(result[i])\n\nreturn result\n\n\ndef product(*args):\n"}
{"task_id":"task/105","completion":"\n\n\"\"\"Merge the elements of each tuple in the args list together.\n\nIf a fill_value is provided, it is used for values of args\n\nwhere there are multiple entries of the same key.\n\n\"\"\"\n\nargs = tuple (args)\n\nfill_value = fill_value or args[ 0 ]"}
{"task_id":"task/106","completion":"\n\n\"\"\"min_by(lst, fn) -> (min, lst)\"\"\"\n\nres = []\n\nfor item in lst:\n\nif fn(item):\n\nres.append(item)\n\nif len(res) == 1:\n\nreturn res[0], lst\n\nreturn"}
{"task_id":"task/106","completion":"\n\n\"\"\" Returns the minimum of a sequence as determined by the key given by the function\n\n>>> min_by(['a', 'b', 'c'], lambda x: -x.lower())\n\n'a'\n\n\"\"\"\n\nreturn min ( filter ( lambda x : fn ( x ) < 0 , lst"}
{"task_id":"task/106","completion":" \"\"\"Min, returns the min of an iterable lst, based on the function fn\"\"\" m = min(lst, key=fn) if m is None: return None return m\n\nPython \u6a21\u5757\u96c6\u5408\n\n\u4ece Python 2.6 \u5f00\u59cb\uff0c\u5b83"}
{"task_id":"task/106","completion":"\n\ndef minby(lst):\n\nif type(lst) == list:\n\nreturn min(lst, key=fn)\n\nelse:\n\nreturn min(lst, key=fn)\n\nreturn minby\n\n\ndef median(lst):\n\nif type(lst)"}
{"task_id":"task/106","completion":"\n\nreturn min(lst, key=fn)\n\nThat is, min_by does the minimum of the list lst using the function fn.\n\nFor min_by to work, it needs to be able to compare any two elements of lst. To do that, it takes the comparison function fn and then calls it"}
{"task_id":"task/107","completion":"\n\nreturn d + timedelta(days = n)\n\n# The following function returns a tuple of the current date and\n\n# the number of seconds since the epoch.\n\ndef get_current_time():\n\n# (datetime.datetime.now() * 1000) - epoch\n\nreturn (datetime."}
{"task_id":"task/107","completion":"\n\nreturn d + timedelta(days = n)\n\ndef add_months(n, d = datetime.today()):\n\nreturn d + timedelta(months = n)\n\ndef add_years(n, d = datetime.today()):\n\nreturn d + timedelta(years = n)"}
{"task_id":"task/107","completion":"\n\n\"\"\"Adds days to a date\"\"\"\n\nd += timedelta(days = n)\n\nreturn d.date()\n\ndef add_hours(n, d = datetime.today()):\n\n\"\"\"Adds hours to a date\"\"\"\n\nd += timedelta(hours = n)\n\nreturn d.time"}
{"task_id":"task/107","completion":"\n\nreturn datetime.combine(d, datetime(d.year, d.month, d.day + n))\n\ndef test_range_stats(n=3, low=0, high=24, steps=1):\n\n\"\"\"\n\nA test case for the RangeStats class.\n\n\"\"\""}
{"task_id":"task/107","completion":"\n\nyield d\n\nd += timedelta(n * 24 * 60 * 60)\n\nd += timedelta(n * 24 * 60 * 60)\n\nd += timedelta(n * 24 * 60 * 60)\n\nyield d\n\ndef add_weeks(n, d = datetime."}
{"task_id":"task/108","completion":"\n\nif s == '':\n\nreturn True\n\nfor i in range(len(s)):\n\nif s[i] != s[len(s) - i - 1]:\n\nreturn False\n\nreturn True\n\ndef is_palindrome(s):\n\nreturn palindrome(s)"}
{"task_id":"task/108","completion":"\n\nreturn s == s[::-1]\n\ndef is_primitive(klass):\n\nreturn type(klass) is type(1)\n\n_input = []\n\ndef __init__(self, *args, **kwargs):\n\nself._input = args\n\nself._kwargs"}
{"task_id":"task/108","completion":"\n\nr = []\n\nfor c in s:\n\nif c != ' ' and c != '\\t' and c != '\n\n' and c != '\\r':\n\nr.append(c)\n\nif len(r) > 1:\n\nreturn False\n\nr.reverse()\n\n"}
{"task_id":"task/108","completion":"\n\n\"\"\"Returns true if s is a palindrome, false otherwise\"\"\"\n\nreturn s == s[::-1]\n\n\nfor s in [\n\n\"No way Jose\",\n\n\"A man, a plan, a canal - Panama!\",\n\n\"Able was I ere I saw Elba\",\n\n"}
{"task_id":"task/108","completion":"\n\n\"\"\"\n\nreturn True if the string is a palindrome\n\n\"\"\"\n\nreturn s == s[::-1]\n\ndef is_palindrome(s):\n\n\"\"\"\n\nreturn True if the string is a palindrome\n\n\"\"\"\n\nreturn palindrome(s)\n\ndef"}
{"task_id":"task/109","completion":"\n\n\"\"\"\n\nSorts the list, ignoring order.\n\n\"\"\"\n\nlst.sort(cmp = None )\n\nif not lst:\n\nreturn None\n\nelse :\n\nreturn lst\n\ndef max ( * lst ):\n\n\"\"\"\n\nReturns the maximum of a list.\n\n"}
{"task_id":"task/109","completion":" return (lambda f: lst and (fn(f()) or f())) #print(none([(2, 3), (4, 5), (6, 7), (8, 9)], lambda x: x[0])) #define x1(a, b) lambda *x: a * b #define x"}
{"task_id":"task/109","completion":" return None if len(lst) == 0 else None return lambda x: x\n\ndef none(lst, fn = lambda x: x): return None if len(lst) == 0 else None return lambda x: x\n\n[T] default def none(lst, fn = lambda x: x): return None"}
{"task_id":"task/109","completion":"\n\nlst[:] = fn(lst[:])\n\n\n\ndef part(lst, count):\n\nlst[:] = [x for x in lst[:count]]\n\n\n\ndef product(lst):\n\nlst[:] = [x * y for x in lst for y"}
{"task_id":"task/109","completion":" if not lst: return None elif not fn(lst[0]): return None else: return lst[1] if len(args) == 1: if isinstance(args[0], int): return none(args[0], lambda x: x) else: return none(args[0], lambda x:"}
{"task_id":"task/110","completion":" return [t for t in lst if t]\n\ndef append(lst, elt): return lst + [elt]\n\ndef head(lst): return lst[0]\n\ndef pop(lst): return lst.pop()\n\ndef last(lst): return lst[-"}
{"task_id":"task/110","completion":"\n\nreturn lst[1:] if lst else [lst[0]]\n\n\ndef test():\n\nprint(head(head(head(head(head([1,2,3,4,5]))))))\n\nprint(tail(tail(tail(tail(tail(tail([1,2,3"}
{"task_id":"task/110","completion":"\n\nprint(lst[len(lst)-1])\n\n#tail([1,2,3,4,5])\n\n#[2,3,4,5]\n\n#tail([1,2,3,4,5,6])\n\n#[2,3,4,5]"}
{"task_id":"task/110","completion":"\n\nreturn (lst[0], tail(lst[1:]))\n\nprint(\"***\")\n\nprint(head_tail(\"abcd\"))\n\nprint(head_tail(\"acbd\"))\n\nprint(head_tail(\"abcde\"))\n\nprint(head_tail(\"abccde\"))\n\n"}
{"task_id":"task/110","completion":"\n\nreturn lst[-1] + [lst[-2]]\n\n\ndef head(lst):\n\nreturn lst[0] + [lst[1:]]\n\n\ndef both(lst):\n\nreturn lst[0] + tail(lst[1:])\n\n\nHere is"}
{"task_id":"task/111","completion":"\n\nhas_duplicates = False\n\nfor x in lst:\n\nif x in lst:\n\nhas_duplicates = True\n\nreturn has_duplicates\n\n4.4.3 \u5224\u65ad\u4e00\u4e2a\u6570\u662f\u5426\u662f\u7d20\u6570"}
{"task_id":"task/111","completion":" if set(lst) != set(set(lst)): return True return False def show_duplicates(lst): if has_duplicates(lst): print \"Original list has duplicates\" print \"\n\n\".join(lst) print \"\n\n\".join(set(lst)) print"}
{"task_id":"task/111","completion":"\n\n\"\"\" Returns True if some item in the list is also in the list.\n\n>>> has_duplicates([1, 2, 2, 3, 2, 1])\n\nTrue\n\n>>> has_duplicates([1, 2, 2, 3, 2, 1])\n\nFalse\n\n>>> has_"}
{"task_id":"task/111","completion":"\n\n#We check if any element in lst is repeated\n\nfor i in lst:\n\nif i in lst:\n\nreturn True\n\nreturn False\n\ndef remove_duplicates(lst):\n\n#The function removes all duplicate elements from the list\n\nsorted_lst = sorted"}
{"task_id":"task/111","completion":"\n\n'''Checks if the list has duplicate values in it\n\n'''\n\nunique_values = []\n\nfor item in lst:\n\nif item not in unique_values:\n\nunique_values.append(item)\n\nreturn len(unique_values) == len(lst)\n\n"}
{"task_id":"task/112","completion":"\n\nfor (key, value) in itr:\n\nfn(key, value)\n\nreturn itr\n\ndef map_files(files, fn):\n\nfor filename in files:\n\nfn(filename)\n\nreturn files\n\ndef get_input(file_input):\n\nfor line in file"}
{"task_id":"task/112","completion":" return itr, fn def map_dict(itr, fn): return itr, lambda d: fn(d) def map_list(itr, fn): return itr, lambda lst: fn(lst) def map_number(itr, fn): return itr, lambda x: fn(x)"}
{"task_id":"task/112","completion":" \"\"\" map_dictionary(itr, fn) -> dictionary \"\"\" if isinstance(itr, tuple): itr = (itr,) cur = {key: value for key, value in itr} return fn(cur) def reduce_dictionary(iterable, fn): \"\"\" reduce_dictionary(iterable, fn"}
{"task_id":"task/112","completion":" return itr.map(fn)\n\n6.4 Generators\n\nA generator function is one that can be paused and resumed, which is particularly useful for producing sequences. One can implement a generator by writing a function that contains a yield statement. When the function is called, it returns a Generator object. This object has a .next"}
{"task_id":"task/112","completion":"\n\ndef dict_fn(*args):\n\nfor k, v in fn(itr).items():\n\nsetattr(itr, k, v)\n\nreturn dict_fn\n\nreturn map_dictionary\n\n# We do this instead of using list.sort() because we want to sort by\n\n#"}
{"task_id":"task/113","completion":"\n\ncounts = defaultdict(int)\n\nfor x in lst:\n\ncounts[fn(x)] += 1\n\nreturn counts\n\ndef my_count_fn(x):\n\nreturn 1 + 2*x + 4*x**2\n\ndef is_even(x):\n\nreturn"}
{"task_id":"task/113","completion":"\n\n''' Count items in list by fn '''\n\nreturn defaultdict(fn)\n\ndef powerset(lst):\n\n'''\n\nReturn the powerset of a set '''\n\nt = set()\n\nfor elem in lst:\n\nif elem not in t:\n\n"}
{"task_id":"task/113","completion":"\n\ncnt = defaultdict(int)\n\nfor x in lst:\n\ncnt[fn(x)] += 1\n\nreturn cnt\n\ndef count_repeat(lst, fn = lambda x: x):\n\ncnt = defaultdict(int)\n\nfor x in lst:\n"}
{"task_id":"task/113","completion":"\n\ncounts = defaultdict(int)\n\nfor i, x in enumerate(lst):\n\nif fn(x):\n\ncounts[fn(x)] += 1\n\nreturn counts\n\ndef product_by(lst, fn = lambda x: x):\n\nproduct = 1\n\nfor"}
{"task_id":"task/113","completion":"\n\n\"\"\"Returns a dictionary whose keys are the number of occurences of each\n\nelement in lst and the values are those elements\"\"\"\n\ndict = defaultdict(int)\n\nfor x in lst:\n\ndict[fn(x)] += 1\n\nreturn dict\n\ndef _is_prime(n"}
{"task_id":"task/114","completion":" if isinstance(a, dict) and not isinstance(b, dict): return dict(x for x in a if fn(x, b) is not None) return a - b def __ne__(self, other): if isinstance(other, dict): if self.__dict__ != other.__dict__:"}
{"task_id":"task/114","completion":" \"\"\" Return the difference between `a` and `b` after applying `fn` to each. For example, ``difference_by(1, 2, lambda x: x - 1)`` returns the list ``[0, 1]``. If `fn` returns `None`, use the identity function `id()` instead."}
{"task_id":"task/114","completion":" \"\"\"Return the elements of a which are not in b\"\"\" if not a or not b: return [] if isinstance(a, list) and isinstance(b, list): return filter(fn, a) if isinstance(a, set) and isinstance(b, set): return filter(fn, a) if isinstance"}
{"task_id":"task/114","completion":" # \u6bd4\u8f83\u6240\u6709\u7684\u5143\u7d20\u540e\u8fd4\u56de\u6bd4\u8f83\u7ed3\u679c return [i for i in a if i != b[i]] # \u91cd\u590d\u6700\u5927\u7684\u957f\u5ea6 def max_repeat(a"}
{"task_id":"task/114","completion":"\n\nreturn (a - b) / fn(a, b)\n\nI decided to use the Python decorator syntax for the time being, but could have used the full Pythonic approach with state classes as well:\n\ndef difference_by(a, b, fn):\n\nreturn (a - b) / fn("}
{"task_id":"task/115","completion":"\n\nreturn d.year, d.month, d.day\n\ndef from_iso_time(t):\n\nreturn (t.hour, t.minute, t.second, t.microsecond)\n\ndef from_iso_string(s):\n\nreturn datetime.strptime(s, \"%"}
{"task_id":"task/115","completion":"\n\n\"\"\"Create a datetime object from an ISO date string.\"\"\"\n\nd = d.replace(':', '.')\n\ny, m, d = d.split('-' if len(d) > 2 else '')\n\nreturn datetime(y, m, d)\n\ndef datetime_iso"}
{"task_id":"task/115","completion":"\n\n'''Convert an ISO date string to a Python datetime instance.\n\nd: An ISO date string.\n\n'''\n\nm = d.split('T')[0]\n\nd = datetime.datetime(m, int(d.split('-')[1]), int(d.split"}
{"task_id":"task/115","completion":"\n\n\"\"\"Convert d to a datetime object.\n\nD should be a string in the format 'YYYY-MM-DD' or 'YYYYMMDD'.\n\n\"\"\"\n\ntry:\n\nreturn datetime.strptime(d, '%Y-%m-%d')\n\nexcept Value"}
{"task_id":"task/115","completion":"\n\n\"\"\"Convert a date string in ISO format to a datetime object.\"\"\"\n\nif d.startswith(\"-\"):\n\nreturn datetime(year=1900+int(d[1:3]), month=d[3:5], day=d[5:7])\n\nreturn datetime(year"}
{"task_id":"task/116","completion":"\n\n\"\"\" Returns a new list with all duplicates removed.\n\n:param lst: list of strings\n\n\"\"\"\n\nunique = []\n\nseen = {}\n\nfor s in lst:\n\nif s not in seen:\n\nseen[s] = True\n\nunique.append(s)\n\n"}
{"task_id":"task/116","completion":"\n\ncounter = Counter(lst)\n\nreturn [x for x in lst if x not in counter]\n\nwith open('my_file.txt') as f:\n\nnon_unique = filter_non_unique(f.readlines())\n\nfor line in non_unique:\n\nprint(line"}
{"task_id":"task/116","completion":"\n\nresults = Counter()\n\nfor item in lst:\n\nif item in results:\n\nresults[item] += 1\n\nelse:\n\nresults[item] = 1\n\nreturn results\n\ndef filter_non_unique_int_values(lst):\n\nresults = Counter()\n\nfor"}
{"task_id":"task/116","completion":"\n\nreturn [item for item in lst if item not in lst]\n\nbacon_counts = Counter([\"bacon\", \"bacon\", \"bacon\", \"bacon\", \"bacon\", \"bacon\", \"bacon\", \"bacon\", \"bacon\", \"bacon\", \"bacon"}
{"task_id":"task/116","completion":"\n\n# This only works if the unique values are in the first half of the list\n\n#\n\n# From http://stackoverflow.com/questions/1305863/how-to-remove-duplicates-from-a-list-in-python\n\n#\n\n# \"This is the trick"}
{"task_id":"task/117","completion":"\n\nc = []\n\nd = []\n\nfor i in range(len(a)):\n\nfor j in range(len(b)):\n\nif a[i] != b[j]:\n\nc.append(a[i])\n\nd.append(b[j])\n\nreturn c"}
{"task_id":"task/117","completion":"\n\nreturn reduce(operator.add, a, b)\n\ndef intersect(a, b):\n\nreturn reduce(operator.add, a, b)\n\ndef subtract(a, b):\n\nreturn reduce(operator.subtract, a, b)\n\ndef diff(a, b):\n\n"}
{"task_id":"task/117","completion":"\n\nreturn a + b * (len(a) - len(b))\n\n\ndef rec_subtree(d, t):\n\nif d == t:\n\nreturn None\n\nelse:\n\nreturn d + rec_subtree(d, t.left) + t.right\n\n\ndef depth_first"}
{"task_id":"task/117","completion":" # The value of a is not changed. c = [] while a != b: c.append(a) a = b b = c return c\n\nBy using a generator expression, the value of a is not changed, only the reference is copied to c. This eliminates the need for a list in the return statement.\n\nSo"}
{"task_id":"task/117","completion":"\n\nif a > b:\n\nreturn {a, b}\n\nelse:\n\nreturn {b, a}\n\n\ndef luhn(n):\n\nreturn sum([is_odd(x) for x in str(n)])\n\n\ndef is_odd(n):\n\nreturn (n &"}
{"task_id":"task/118","completion":"\n\n\"\"\" Snakes are nice. \"\"\"\n\nreturn s\n\ndef wrap(s, width):\n\n\"\"\" Wraps the string at a given column. \"\"\"\n\nreturn ' ' * (width - len(s)) + s\n\ndef width_bytes(width):\n\n\"\"\" Returns the number of bytes required to display"}
{"task_id":"task/118","completion":"\n\n\"\"\"\n\nReturn a string of 's' where each letter is replaced with a\n\nrandom English letter in the same position.\n\n\"\"\"\n\nsub('', s)\n\n# random order\n\nfor i in range(len(s)):\n\nj = random.randint(0, len(s"}
{"task_id":"task/118","completion":"\n\n# Replace all symbols with the same symbol\n\nfor i in range(len(s)):\n\nif s[i] != s[i-1]:\n\nif s[i] == '*':\n\nfor j in range(i+1, len(s)):\n\ns[j] ="}
{"task_id":"task/118","completion":"\n\nwhile len(s)>0:\n\ns = s[1:] + s[:-1]\n\ns = s[::-1]\n\nreturn s\n\ndef snake_and_eat(s):\n\ns = snake(s)\n\ns = s[:-1] + s[1"}
{"task_id":"task/118","completion":"\n\n\"\"\"Take a string and return a string with a snake on each\n\nline, with the snake facing left.\"\"\"\n\n# Note: \"q\" is the same as \"quit\". If a user inputs \"q\",\n\n# we have to assume that the user is not interested in\n\n# playing the game.\n"}
{"task_id":"task/119","completion":" return flat_dict.items() def keys_only(flat_dict): return flat_dict.keys() def all_keys(flat_dict): return flat_dict.keys() def all_keys(flat_dict): return flat_dict.values() def all_keys(flat_dict): return flat_dict.items"}
{"task_id":"task/119","completion":"\n\nresult = {}\n\nfor key in flat_dict.keys():\n\nresult[key] = flat_dict[key]\n\nreturn result\n\ndef keys_and_values(flat_dict):\n\nresult = {}\n\nfor key in flat_dict.keys():\n\nresult[key] = flat"}
{"task_id":"task/119","completion":"\n\nflat_dict = flat_dict.items()\n\nfor key in flat_dict:\n\nif key not in list (get_keys(flat_dict)):\n\nflat_dict.pop(key)\n\nreturn flat_dict\n\ndef sort_indices_from_keys(flat_dict):"}
{"task_id":"task/119","completion":" return list(flat_dict.keys())\n\nAs the name suggests, keys_only will return a list of keys, but not the values.\n\nSo, that\u2019s it!\n\nI hope this article will help you to understand how Python dictionary works internally.\n\nIf you like what you just read, please consider"}
{"task_id":"task/119","completion":" # flat_dict is a dictionary with only the keys # return the keys as a list return flat_dict.keys() # keys_only is a function # keys_only = {'a': 1, 'b': 2, 'c': 3} print(keys_only(keys_only)) # ['a', 'b',"}
{"task_id":"task/120","completion":"\n\nreturn num % 2 == 1\n\n\n# Use is_odd to build a statement that calls itself:\n\ndef factorial(num):\n\nif is_odd(num):\n\nreturn num * factorial(num-1)\n\nelse:\n\nreturn num * factorial(num-1)\n\n\n"}
{"task_id":"task/120","completion":"\n\n\"\"\"\n\nInput: 1,2,3,4,5,6\n\nOutput: True\n\n\"\"\"\n\nif num % 2 == 0:\n\nreturn False\n\nelse:\n\nreturn True\n\ndef is_positive(num):\n\n\"\"\"\n\nInput: 4,8,9,0"}
{"task_id":"task/120","completion":"\n\nif num % 2 == 0:\n\nreturn False\n\nelse:\n\nreturn True\n\n#implementing it\n\nif is_odd(1):\n\nprint(\"1 is odd.\")\n\nelse:\n\nprint(\"1 is even.\")\n\nOutput:\n\n1 is odd.\n\n2"}
{"task_id":"task/120","completion":" if num % 2 == 0: return False else: return True is_odd = a @property def second_property(self): return self.first_property * 2 @second_property.setter def second_property(self, value): self.first_property = value 1 2 3 4 5 6 7 8 9 10 11 12"}
{"task_id":"task/120","completion":"\n\n\"\"\"\n\nReturn True if `num` is odd, False otherwise.\n\n\"\"\"\n\nreturn num % 2 == 1\n\ndef is_even(num):\n\n\"\"\"\n\nReturn True if `num` is even, False otherwise.\n\n\"\"\"\n\nreturn num % 2 == 0\n\nif __name"}
{"task_id":"task/121","completion":"\n\n\"\"\"Group a sequence by a key.\n\nLike `groupby` but no default value is required.\n\n\"\"\"\n\nif not lst:\n\nreturn\n\nreturn defaultdict(list)\n\ndef find_group(lst, fn):\n\n\"\"\"Find all distinct values returned by `fn`.\""}
{"task_id":"task/121","completion":"\n\n\"\"\"Return a list of lists with the same length as lst. Each list\n\ncontains items of lst grouped according to fn(item).\n\n>>> group_by(['abc', 'a', 'b', 'c'], str.lower)\n\n[('a', 'abc'), ('b', '"}
{"task_id":"task/121","completion":"\n\nreturn (defaultdict(list) for x in lst for y in x for fn(y) in y)\n\ndef show_sorted(lst):\n\nprint('\n\n'.join(sorted(lst, key=fn)))\n\ndef count_sorted(lst, fn):\n"}
{"task_id":"task/121","completion":"\n\n'groupby: return list of lists, where each sublist contains\n\nelements that are all equivalent when passed as the first\n\nargument to fn'\n\nreturn defaultdict(list)\n\ndef group_by_equivalence(lst, fn):\n\n'groupby_equivalence: return"}
{"task_id":"task/121","completion":"\n\n\"\"\"\n\nReturn a generator that produces lists of items, grouped according to fn(item).\n\nExamples\n\n--------\n\n>>> list(group_by(['abc', 'def'], str.lower))\n\n['a', 'b', 'c', 'd', 'e', 'f']\n\n>>>"}
{"task_id":"task/122","completion":"\n\nif n < 0x00100000:\n\nn = ((n & 0xFFFFFF) << 21) | ((n >> 21) & 0xFFFFFF)\n\nif n < 0x00100000:\n\nn = ((n & 0xFFFFFF) << 14) | ((n >> 14)"}
{"task_id":"task/122","completion":" return bin(n)[2:] def from_binary(s): return int(s,2) def find_majority(s): maj = 0 for i in s: if i > maj: maj = i return maj def find_majority_str(s): maj = 0 for i in s: if i > maj: maj ="}
{"task_id":"task/122","completion":"\n\nreturn bin(n).rjust(8, '0')\n\n\ndef to_hex(n):\n\nreturn ''.join(str(n) for n in range(1, 16) if n != 0)\n\n\ndef to_decimal(n):\n\ntry:\n\nreturn int(n,"}
{"task_id":"task/122","completion":" '''convert numbers to binary''' num = n * 2 exponent = math.log(num, 2) + 1 return (num, exponent) def get_digits(n): '''reverse digits and return number''' n = n[::-1] + [0] return int(n) def check_dig"}
{"task_id":"task/122","completion":"\n\n''' :param n: integer :return: binary representation of n '''\n\nb = '0b'\n\nfor nr in xrange(0, n):\n\nb += '1' * (2 ** (nr & 0x f))\n\nreturn b\n\n\ndef to_decimal(n"}
{"task_id":"task/123","completion":"\n\nreturn ''.join(lst)\n\n\ndef main():\n\ntotal = [1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10]\n\nfor i in range(len(total)):"}
{"task_id":"task/123","completion":" if len(lst) > 1: return [x for x in lst if x not in lst[1:]] else: return lst[0] >>> lst = ['x', 'y', 'x', 'z'] >>> compact(lst) ['x', 'y', 'z'] >>> compact(['"}
{"task_id":"task/123","completion":"\n\n\"\"\"\n\n\u53ea\u8981\u7ed9\u51fan\u4e2a\u5143\u7d20\uff0c\u5c31\u53ef\u4ee5\u538b\u7f29n\u4e2a\u5143\u7d20\uff0c\u56e0\u4e3a\u538b\u7f29\u540e\u4ecd\u662fn\u4e2a\u5143\u7d20\n"}
{"task_id":"task/123","completion":"\n\nreturn lst[1:] if lst[0] == lst[1:] else lst[0]\n\ndef empty_filename(base):\n\nreturn \"_empty_\" + base\n\ndef parse_content_type(str):\n\nt = 0\n\nfor c in str:\n\nt"}
{"task_id":"task/123","completion":"\n\nif lst != []:\n\n# lst = ['B', 'A', 'C', 'D'] -> lst = ['B', 'A', 'C', 'D']\n\nlst = lst[:len(lst)-1] + lst[-1:]\n\nreturn lst"}
{"task_id":"task/124","completion":" \"\"\"InRange(n, start, end) -> True if n is in the range start <= n < end.\"\"\"\n\n# It would be nice to use the fast C version for this.\n\n# But n is not guaranteed to be a native int.\n\nn_d = [int(i) for i in n"}
{"task_id":"task/124","completion":" \"\"\" Check if a number is in the range given. \"\"\" if n >= start and n <= end: return True else: return False\n\nBesides the function, we also have a special \"class-method\" that lets us call this function as a method of a class.\n\n>>> class MyClass(object): ... def __init__"}
{"task_id":"task/124","completion":"\n\nreturn (n >= start and n <= end)\n\n\nif __name__ == '__main__':\n\nprint(0 in_range(5))\n\nprint(1 in_range(5))\n\nprint(2 in_range(5))\n\nprint(3 in_range(5))\n\n"}
{"task_id":"task/124","completion":"\n\n'Binary search for a number in a range'\n\nreturn n >= start and n <= end\n\n\ndef in_range_exact(n, start, end = 0):\n\n'Binary search for a number in a range (exact)'\n\nreturn n >= start and n <= end\n\n\ndef"}
{"task_id":"task/124","completion":"\n\n# we check for the range of the value\n\nreturn (n >= start) and (n <= end)\n\n\nclass Numeric:\n\ndef __init__(self, name, number):\n\nself.name = name\n\nself.number = number\n\n\ndef __repr__(self):\n\n"}
{"task_id":"task/125","completion":"\n\n\"\"\"\n\nReturn date objects for the interval.\n\n\"\"\"\n\nreturn (date(end - timedelta(days=1)),\n\ndate(end - timedelta(days=2)),\n\ndate(end - timedelta(days=3)),\n\ndate(end - timedelta(days=4)))\n"}
{"task_id":"task/125","completion":"\n\n\"\"\"Create a date range (start and end)\"\"\"\n\nreturn date(start.year, start.month, start.day)\n\n+ timedelta(days=end.days_from(start))\n\ndef timerange(start, end):\n\n\"\"\"Create a timerange (start and end)\"\"\"\n"}
{"task_id":"task/125","completion":"\n\n\"\"\" Given start and end datetimes, return a list of datetimes\n\nthat represents the duration.\n\n\"\"\"\n\nd = timedelta(days=end - start)\n\nd += timedelta(days=1)\n\nreturn [d.date()] + list(d.timedelta(days="}
{"task_id":"task/125","completion":"\n\nif end < start:\n\nreturn -1, None\n\nreturn start, end\n\ndef validate_schedule(schedule):\n\n\"\"\"\n\n:param schedule:\n\n:return:\n\n\"\"\"\n\n# Sanity check\n\n# No bad guys\n\nfor team in schedule:\n\nif"}
{"task_id":"task/125","completion":"\n\nif not start or not end:\n\nraise ValueError('At least one of start or end must be '\n\n'defined')\n\nif start < end:\n\nif end > datetime.max:\n\nend = datetime.max\n\nif start > datetime.min:\n\nstart = dat"}
{"task_id":"task/126","completion":"\n\nif len(lst) <= size:\n\nreturn lst\n\nreturn chunk(lst[:size], size) + lst[size:]\n\ndef flat_map(f, lst):\n\nreturn list(map(f, chunk(lst, len(lst)//2)))\n"}
{"task_id":"task/126","completion":"\n\n\"\"\"\n\nSplit a list into chunks.\n\n\"\"\"\n\nrem = len(lst) % size\n\nif rem == 0:\n\nreturn [lst]\n\nelse:\n\nreturn [lst[:rem] + chunk(lst, size) + lst[rem:]]\n\n"}
{"task_id":"task/126","completion":"\n\n'''Divide a list into equal length pieces'''\n\nn = len(lst)\n\nchunks = []\n\nfor i in range(0, n/size):\n\nchunks.append(lst[i*size:(i+1)*size])\n\nreturn chunks\n\ndef join"}
{"task_id":"task/126","completion":"\n\nif lst:\n\ns = []\n\ni = 0\n\nlst = list(lst)\n\nwhile i < len(lst):\n\ns.append(lst[i])\n\ni += 1\n\nif i > 0:\n\ns[-1] = lst["}
{"task_id":"task/126","completion":"\n\nchunk = []\n\ni = 0\n\nwhile i < len(lst):\n\nx = lst[i]\n\nlst[i] = lst[i+1]\n\nlst[i+1] = x\n\nchunk.append(x)\n\ni += 1"}
{"task_id":"task/127","completion":"\n\nif isinstance(lst, Iterable):\n\nif isinstance(lst, collections.Mapping):\n\nreturn lst\n\nelse:\n\nreturn deep_flatten(deep_flatten(lst))\n\nelse:\n\nreturn [lst]\n\n\n>>> lst = [[1"}
{"task_id":"task/127","completion":"\n\nif isinstance(lst, (Iterable, list)):\n\nreturn deep_flatten(iter(lst))\n\nelse:\n\nreturn [deep_flatten(x) for x in lst]\n\nif __name__ == '__main__':\n\nlst = [\n\n"}
{"task_id":"task/127","completion":"\n\n\"\"\"deep_flatten([[1, 2], [3, 4]]) --> [1, 2, 3, 4]\"\"\"\n\nfor el in lst:\n\nfor lst2 in deep_flatten(el):\n\nyield lst2\n\n# map\u51fd\u6570\u662fPython\u4e2d"}
{"task_id":"task/127","completion":"\n\nif isinstance(lst, Iterable):\n\nfor i in lst:\n\nyield from deep_flatten(i)\n\nyield from lst\n\ndef square(lst):\n\nfor i in lst:\n\nyield i * i\n\ndef cube(lst):"}
{"task_id":"task/127","completion":"\n\n\"\"\"\n\n`lst` is a list-like object.\n\nReturns a new list where each element is the result of a\n\ndeep_flatten on its respective element.\n\n\"\"\"\n\nreturn [deep_flatten(x) for x in lst]\n\ndef _invert_dict("}
{"task_id":"task/128","completion":"\n\nlist_with_values = []\n\nfor i in range(n):\n\nlist_with_values.append(val)\n\nreturn list_with_values\n\ndef new_list_with_values(n, val = 0):\n\nnew_list_with_values = []\n\nfor i"}
{"task_id":"task/128","completion":"\n\nresult = []\n\nfor i in range(n):\n\nresult.append(val)\n\nreturn result\n\n4.4.4 \u4e0d\u4f7f\u7528\u53ef\u53d8\u53c2\u6570\u7684\u521d\u59cb\u5316\u89c4\u5219\n\n\u4e0d\u4f7f\u7528\u53ef\u53d8\u53c2"}
{"task_id":"task/128","completion":"\n\nself.items = [val] * n\n\nself.len = n\n\ndef __iter__(self):\n\nreturn self\n\n\n\ndef next(self):\n\nval = self.items[self.len]\n\nself.len += 1\n\nreturn val\n\n\n\ndef __getitem__"}
{"task_id":"task/128","completion":"\n\nlist_with_values = []\n\nfor i in range(n):\n\nlist_with_values.append(val)\n\nreturn list_with_values\n\ndef test(n):\n\nreturn [(i for i in range(n))]\n\n\n\nprint(test(5))\n\nprint"}
{"task_id":"task/128","completion":" + for i in range(n): + this_list.append(val) + + def test_list_copy(): + l1 = [1, 2, 3] + l2 = l1 + l2[0] = 3 + l2[1] = 4 + l2[2] = 5 + + self"}
{"task_id":"task/129","completion":"\n\nreturn sum(lst) / float(len(lst))\n\ndef median_by(lst, fn = lambda x: x):\n\nif len(lst) % 2 == 1:\n\nmiddle = len(lst) / 2\n\nelse:\n\nmiddle = (len(lst"}
{"task_id":"task/129","completion":" return reduce(lambda x, y: x + y, lst, 0) / (len(lst) if fn else lambda x: x) if (len(lst) > 0) else 0\n\n\"\"\"\n\ndef average_by(lst, fn = lambda x: x):\n\nreturn reduce(lambda"}
{"task_id":"task/129","completion":" return sum(fn(i) for i in lst) / len(lst)\n\nIn a sense, these two definitions of the average_by function are equivalent. However, the second version is more succinct and avoids repeating the argument x in the body of the function. In general, using lambda as an abbreviation for a function"}
{"task_id":"task/129","completion":"\n\nlst = list(lst)\n\ntotal = 0\n\nfor x in lst:\n\ntotal += fn(x)\n\nreturn total/len(lst)\n\ndef median_by(lst, fn = lambda x: x):\n\nlst = list(lst)\n\n"}
{"task_id":"task/129","completion":" avg = 0.0 for x in lst: avg += fn(x) return avg\n\navg_num = average_by(lst, lambda x: x)\n\n$ time python fibonacci_average.py 50 Real: 0m0.095s\n\n1000000\n\n1000000\n\n"}
{"task_id":"task/130","completion":"\n\nreturn d.max()\n\ndef sort_by_max(d):\n\nd.sort(key=key_of_max)\n\nif __name__ == \"__main__\":\n\nd = [[1,2,3],[4,5,6],[7,8,9],[10,11"}
{"task_id":"task/130","completion":"\n\nif d is KeyError:\n\nreturn -1\n\nelif d is int:\n\nreturn d\n\nelif d is str:\n\ntry:\n\nreturn int(d)\n\nexcept ValueError:\n\nreturn -1\n\nelif d is dict:\n\nreturn max(d."}
{"task_id":"task/130","completion":"\n\nreturn d.keys()[0]\n\ndef add_to_dict(d, k, v):\n\nd[k] = v\n\ndef remove_from_dict(d, k):\n\ndel d[k]\n\ndef set_to_dict(d, k, v):\n\n"}
{"task_id":"task/130","completion":"\n\nreturn d.get('_key', None)\n\n\ndef read_data(d):\n\n\"\"\"\n\nReturns the hash value of the data object, or None if the object\n\nisn't found.\n\n\"\"\"\n\nif key_of_max(d) in s.keys():\n\nreturn s"}
{"task_id":"task/130","completion":"\n\n\"\"\"\n\nReturns the key of the highest value in the\n\ndictionary.\n\n\"\"\"\n\nreturn d.keys()[d.max()]\n\ndef avg_of_max(d):\n\n\"\"\"\n\nReturns the average of the highest value in the\n\ndictionary.\n\n\"\"\"\n\n"}
{"task_id":"task/131","completion":"\n\n\"\"\" offset\u51fd\u6570\u7edf\u8ba1\u67d0\u4e2a\u5b9e\u4f53\u5728\u67d0\u4e00\u5217\u4e2d\u7684\u6700\u5c0f\u503c\uff0c\u4e14\u5982\u679c\u6709\u4e0d\u5b58\u5728\u5c31\u4e3a0\n\n\"\"\"\n\nif lst"}
{"task_id":"task/131","completion":" return lst[offset]\n\nHowever, this is not a good solution. If you want to remove the offset from the list, you need to remember to call this function with an offset of zero. If you forget and call the function with an offset of one, the offset will be included in the result. This is really a problem with"}
{"task_id":"task/131","completion":" \"\"\"Return a slice of lst from offset to the end of the list.\"\"\" return lst[offset:offset+1] def range(start, stop, step=1): \"\"\"Return a list containing the integers from start (inclusive) to stop (exclusive).\"\"\" if step == 0: return [start] elif step =="}
{"task_id":"task/131","completion":"\n\nlst = lst[:offset] + lst[offset:]\n\nreturn lst\n\n\ndef find_first_of(item, lst):\n\nfor i in range(len(lst)):\n\nif item == lst[i]:\n\nreturn i\n\nreturn -1\n\n\n"}
{"task_id":"task/131","completion":"\n\n\"\"\"\n\n\"\"\"\n\nreturn lst[offset]\n\ndef find(lst, value):\n\n\"\"\"\n\n\"\"\"\n\nfor i in range(len(lst)):\n\nif lst[i] == value:\n\nreturn i\n\nreturn -1\n\ndef del(lst"}
{"task_id":"task/132","completion":" ... def _intersection(self, other): ... def _complement(self, other): ... - def clone(self): ... + def clone(self, args): ... def clear(self): ... def contains(self, element): ... def copy(self): ... @@ -508,10 +513,12 @@ class _Hash"}
{"task_id":"task/132","completion":" try: return fn(a, b) except TypeError: return lambda x, y: x == y intersection_by(1, 2, lambda x, y: x > y) #=> 2 intersection_by(1, 2, lambda x, y: x <= y) #=> 2 intersection_by(1, 2,"}
{"task_id":"task/132","completion":" return len(set(a).intersection(set(b))) a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] b = [2, 3, 4, 5, 6, 7, 8, 9, 10, 11] def gcd(a, b): return b"}
{"task_id":"task/132","completion":"\n\nif type(a) is type(b):\n\nreturn lambda x: (fn(x, a) if fn(x, a) else x)\n\nelse:\n\nreturn lambda x: (fn(x, b) if fn(x, b) else x)\n\n#\n\n# Compute"}
{"task_id":"task/132","completion":" \"\"\" `intersection_by(a, b, fn)` returns a dictionary whose keys are all the elements of `a` that are also in `b`, and whose values are the same as `f(k)` for each key `k` in `a` also in `b`. >>> intersection_by([1, 2"}
{"task_id":"task/133","completion":"\n\n+ return type(a) is type(b) and a.union_by(b, fn)\n\n+\n\n+ def is_eq(a, b):\n\n+ return type(a) is type(b) and a.is_eq(b)\n\n+\n\n+ def __eq"}
{"task_id":"task/133","completion":" return a.union_by(b, fn) >>> Union(set([1, 2, 3]), set([2, 3, 4, 5, 6])) {1, 2, 3, 4, 5, 6}\n\n\u4f18\u96c5\u7684\u7edf\u8ba1\u51fd\u6570\n\n>>> def stats"}
{"task_id":"task/133","completion":" return {k: v for k, v in zip(a, b) if fn(k, v)}\\r\n\nresult = {10: 1, 11: 2, 12: 3, 13: 4, 14: 5}\\r\n\nfor i in range(1, 15):\\r\n\nprint('union_"}
{"task_id":"task/133","completion":"\n\nif isinstance(a, tuple) and isinstance(b, tuple):\n\nreturn tuple(union_by(a, b, fn))\n\nelse:\n\nreturn fn(a, b)\n\ndef cartesian_product(a, b):\n\nif isinstance(a, tuple) and is"}
{"task_id":"task/133","completion":"\n\nresult = []\n\nfor x in a:\n\nif x in b:\n\nresult.append(fn(x, b[x]))\n\nreturn result\n\ndef remove_duplicates(a):\n\n'''\n\nRemove duplicates from the list a\n\n'''\n\nresult ="}
{"task_id":"task/134","completion":" \"\"\"returns all unique elements in lst\"\"\" unique = [] for item in lst: if item not in unique: unique.append(item) return unique def remove_duplicates(lst): \"\"\"returns a copy of lst without any duplicates\"\"\" uniques = all_unique(lst) return [x for"}
{"task_id":"task/134","completion":" \"\"\" >>> a = [1, 2, 2, 2, 3, 2, 3, 3, 3, 3, 4, 4, 5, 6, 7, 7, 8, 8, 9, 10] >>> all_unique(a) [1, 2, 3, 4, 5, 6, 7, 8, 9"}
{"task_id":"task/134","completion":" lst.sort() for i in range(len(lst)): if (lst[i] != lst[i+1]): return True return False #lst = [\"AAA\", \"BBB\", \"CCC\", \"DDD\", \"EEE\"] #lst.sort() #print(all_unique("}
{"task_id":"task/134","completion":" return list(set(lst)) def distinct(lst): return list(set(lst)) def is_distinct(lst): return (len(lst) == len(list(set(lst)))) def is_unique(lst): return (len(lst) == len(list(set("}
{"task_id":"task/134","completion":" \"\"\" filter out duplicate elements from list lst\"\"\" if not lst: return [] return set(lst) def is_pair(x): \"\"\" return True if x is a pair (x, y) where x is a primitive type, False otherwise \"\"\" return type(x) in ['int', 'float', 'str', 't"}
{"task_id":"task/135","completion":"\n\nraise NotImplementedError()\n\n\ndef update(lst, key, val):\n\nraise NotImplementedError()\n\n\ndef search(lst, key):\n\nraise NotImplementedError()\n\n\ndef __init__(self, lst, key=None):\n\nself.key"}
{"task_id":"task/135","completion":"\n\nresult = []\n\nfor e in lst:\n\nif e[key] == key:\n\nresult.append(e)\n\nreturn result\n\ndef main():\n\nprint(\u201cPlease enter a key\u201d)\n\nkey = input()\n\nprint(\u201cPlease enter a list"}
{"task_id":"task/135","completion":"\n\n\"\"\"\n\nReturn a list with the values of `key` found in `lst`\n\n\"\"\"\n\nreturn [v for k, v in lst if key == k]\n\ndef main():\n\ni = 0\n\n# This list will contain the data we want to parse into\n\n# our table"}
{"task_id":"task/135","completion":"\n\nif key in lst:\n\nreturn lst[key]\n\nelse:\n\nreturn None\n\nval_dict.update(pluck(data, 'type'))\n\nIn the preceding code, we first read the data attribute of the form to get the list of data fields, then we go through each"}
{"task_id":"task/135","completion":"\n\nreturn getattr(lst, key)\n\ndef make_key_and_tuple(key, value):\n\nreturn key, value\n\nclass Dict(dict):\n\ndef __init__(self, init=()):\n\nself.init = init\n\ndef __setitem__(self"}
{"task_id":"task/136","completion":" for elem in itr: fn(elem) for elem in for_each(itr): fn(elem)\n\nIn this case, for_each is an iterable factory, which produces an iterable that loops over all items in the iterable it receives as an argument. We call for_each with an"}
{"task_id":"task/136","completion":" for item in itr: fn(item)\n\nfor_each.py\n\n\ndef for_each(itr, fn): for item in itr: fn(item)\n\nfor_each.py\n\n\ndef for_each(itr, fn): for item in itr: fn(item)\n\n"}
{"task_id":"task/136","completion":" return [fn(x) for x in itr]\n\n\nThen, we can write:\n\nfor_each(sorted(v), lambda x: x**2)\n\n\nOr, we can write:\n\nfor_each(sorted(v), lambda x, y: x + y)\n\n\nThis id"}
{"task_id":"task/136","completion":" pass for_each(range(5), print)\n\n\nThe for_each function defines the function (fn) that will be called for each item in the iteration. The function (fn) will be called as itr.fn(itr), so the variable itr must be defined in the function (fn). In this case,"}
{"task_id":"task/136","completion":" + return [fn(x) for x in itr] + +def print(fn): + print >> sys.stderr, fn.__name__ + +def stringify(x): + return repr(x) + +def sys_exit(code): + raise SystemExit(code) + +def call_with"}
{"task_id":"task/137","completion":" return lambda x: fn(x) if isinstance(lst, list) else [fn(x) for x in lst] def every(lst, fn = lambda x: x): return lambda x: lambda y: fn(x) and fn(y) if isinstance(lst, list) else [fn"}
{"task_id":"task/137","completion":" \"\"\"Generate a stream that passes every element through the given function\"\"\" if not lst: return while True: x = lst.pop(0) if fn(x): yield x def take(n, lst): \"\"\"Generate a stream that passes the first n elements of the given list.\"\"\" if n <= 0: return"}
{"task_id":"task/137","completion":" return [fn(x) for x in lst] def main(): fns = every(open('test1.txt'), readlines) for line in fns: print line, if __name__ == '__main__': main()\n\ntest1.txt\n\ntest1.txt:\n\nlines 1,2"}
{"task_id":"task/137","completion":" if not lst: return lst return [fn(x) for x in lst]\n\nTo make this a little clearer, here's an example of using it:\n\n>>> def every_element(lst): ... return True ... >>> every(range(10), every_element) [0, 1, 2,"}
{"task_id":"task/137","completion":" \"\"\"Converts [lst] into a list of 1s where fn returns true, and 0s otherwise\"\"\" if all(fn(x) for x in lst): return [1] else: return [0]\n\n4.3.3 . . . . . . . . . . . . . . . . ."}
{"task_id":"task/138","completion":"\n\nreturn struct.calcsize(s)\n\ndef print_size(s):\n\nreturn repr(struct.calcsize(s))\n\ndef main():\n\n# Read a file, try to guess its type, and determine its size.\n\n#\n\n# If the file type isn't recognized,"}
{"task_id":"task/138","completion":"\n\nfor char in s:\n\nif char in string.digits:\n\nreturn 1\n\nreturn 2\n\ndef big_endian(s):\n\nfor char in s:\n\nif char in string.digits:\n\nreturn 1\n\nreturn 0\n\ndef little_endian(s):"}
{"task_id":"task/138","completion":"\n\n# size in bytes of a str instance\n\nreturn struct.calcsize(s)\n\n\nclass StrUnpickler(object):\n\n\"\"\"Unpickler for the new str type.\"\"\"\n\n\ndef __init__(self, f):\n\nself.f = f\n\n\ndef loads(self, s"}
{"task_id":"task/138","completion":"\n\nsize = 0\n\nfor c in s:\n\nsize += 1\n\n\n\nreturn size\n\n\n\ndef get_size(s):\n\nsize = 0\n\nfor c in s:\n\nsize += 1\n\n\n\nreturn size\n\n\n\ndef get_bin_size(s):\n\nsize ="}
{"task_id":"task/138","completion":"\n\nreturn struct.calcsize(struct.pack('>L', len(s)))\n\ndef bytes_size(s):\n\nreturn struct.calcsize(struct.pack('>L', len(s)))\n\ndef write_file(filename, data):\n\nfd = open(filename, 'wb"}
{"task_id":"task/139","completion":"\n\nif l < 0:\n\nreturn n - int(n / l) * l\n\nreturn n\n\n\n\ndef add_hyphens(n):\n\nl = int(n / 10) * 10\n\nn = int(n / 100) * 100\n\nl = int(n / 1000) *"}
{"task_id":"task/139","completion":"\n\nn = int(n)\n\nfor i in range(len(n)):\n\nn = \"0\" + n\n\nreturn n\n\n\ndef remove_nums(n):\n\nfor i in range(len(n)):\n\nif n[i] == \"0\":\n\nn ="}
{"task_id":"task/139","completion":" # returns string of l 0s appended to n if n <= 0: return '0' else: return str(n) + '0' * (l - len(str(n))) i = 0 for arg in arg_list: i += 1 for j in range(i): arg_list[j] = arg_"}
{"task_id":"task/139","completion":"\n\nn = int(n)\n\nif n < 0:\n\nn = -n\n\nif n % 10 == 0:\n\nn = '0' + n\n\nreturn n\n\n\nprint(pad_number(7, 4))\n\nprint(pad_number(-7, 4))\n\nprint"}
{"task_id":"task/139","completion":" if n < 0: n = -n elif n > 9999: n = 9999 else: n = n + 0 pad_number = lambda n, l: '%0%i' % (n, l) # Pad a number to a given length. def pad_number_to_length(n, l):"}
{"task_id":"task/140","completion":"\n\n# from pypy.objspace.std.container import Iterator, Container\n\n#\n\n# itr = Iterator(itr)\n\n# container = Container(container)\n\n# try:\n\n# while True:\n\n# try:\n\n# try:\n\n# itr."}
{"task_id":"task/140","completion":"\n\ni = 0\n\nwhile i < len(itr):\n\nfn(i)\n\ni += 1\n\ndef make_clones(iterable):\n\n\"\"\"Return an iterator that clones the elements of iterable\"\"\"\n\nreturn iter(lambda: iter(iterable).__next__())\n\ndef"}
{"task_id":"task/140","completion":" + for_each_right(itr, fn, False) # calling for_each_right with argument True + def for_each_right(itr, fn): + for i in itr: + fn(i) + if (test_or_none(i, itr)): + break + return + +"}
{"task_id":"task/140","completion":"\n\n+ for_each_right(itr, fn):\n\n# Go through the right node entries and find all of the\n\n# right-most nodes that are not already in the rightmost tree.\n\n- right_root = right_leaf.find_rightmost_node(right_root)\n\n-"}
{"task_id":"task/140","completion":" # ...\n\nfor_each_right() is a function that works like for_each() , except that it iterates through a container in a right-to-left order. This allows you to use it to process the right-most element of the iterable first, and works well when the iteration is driven by the call to each"}
{"task_id":"task/141","completion":"\n\n\"\"\"Check if two strings are anagrams.\"\"\"\n\nreturn any(c1 == c2 for c1, c2 in zip(s1, s2))\n\n\nif __name__ == '__main__':\n\nimport operator\n\nprint(\"Operator Method:\")\n\nc1 = Counter('"}
{"task_id":"task/141","completion":"\n\n\"\"\"Return True if strings s1 and s2 are anagrams.\n\nAnagrams are words that can be rearranged to form another\n\nword, e.g. \\\"mice\\\" and \\\"cime\\\" are anagrams of each other.\n\n>>> is_anagram('bbbb', 'aaa"}
{"task_id":"task/141","completion":"\n\n\"\"\"\n\nReturns True if s1 and s2 are anagrams, False otherwise.\n\ns1 and s2 can be either str or unicode objects.\n\n\"\"\"\n\nc1 = Counter(s1)\n\nc2 = Counter(s2)\n\nreturn all(c1.get("}
{"task_id":"task/141","completion":"\n\n\"\"\"\n\n:param s1:\n\n:param s2:\n\n:return:\n\n\"\"\"\n\n\"\"\"\n\ns1 = s1.lower()\n\ns2 = s2.lower()\n\nreturn s1.isidentical(s2) and len(s1) == len("}
{"task_id":"task/141","completion":"\n\n\"Returns True if s1 and s2 are anagrams\"\n\nreturn s1.lower() == s2.lower() and \\\n\nlist(set(s1) & set(s2)) == set([])\n\ndef is_substring(s1, s2):\n\n\"Returns True"}
{"task_id":"task/142","completion":"\n\n\"\"\"\n\nreturns the string s with non-capitalized letters replaced with their lowercase\n\nequivalents. If upper_rest is True, the rest of the string is also\n\ndecapitalized.\n\n\"\"\"\n\nif upper_rest:\n\nreturn s.upper() + s[:1"}
{"task_id":"task/142","completion":"\n\n\"\"\"\n\nReplace digits in `s` with the first letter of their name.\n\nIf `upper_rest` is `True`, keep the rest of the letters as is.\n\n\"\"\"\n\n# int-like semantics:\n\n# ```\n\n# >>> decapitalize(\"1000000\")\n\n"}
{"task_id":"task/142","completion":"\n\ndef do_del(e):\n\nif upper_rest:\n\nif e == 'I':\n\nif e == 'A':\n\nif e == 'U':\n\nif e == 'Y':\n\nif e == 'I':\n\nif e == 'O':\n\nif e == '"}
{"task_id":"task/142","completion":"\n\n\"\"\"\n\nDecapitalizes a string or a portion of a string.\n\nDoes not work with ASCII characters.\n\n\"\"\"\n\nif upper_rest:\n\nreturn s.upper() + s[1:].lower()\n\nelse:\n\nreturn s.lower() + s[1:].upper"}
{"task_id":"task/142","completion":" return s if upper_rest else s.capitalize()\n\n>>> def titleize(s):\n\n... return s.title()\n\n>>>\n\n>>> def is_empty(s):\n\n... return s == ''\n\n>>>\n\n>>> def is_numeric(s):\n\n... return isinstance("}
{"task_id":"task/143","completion":"\n\n\"\"\"\n\ndef unique_elements(li):\n\n\"\"\"\n\n# TODO(grahamedgecombe):\n\n# TODO(grahamedgecombe):\n\n# Remove this once https://github.com/plasma-org/plasma-desktop/pull/414 is merged\n\n#"}
{"task_id":"task/143","completion":" if len(li) == 0: return [] else: return [e for e in li if e not in li[1:]]\n\n(4) \u67e5\u8be2\u8bb0\u5f55\u5e93\n\n\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u4e0a\u9762\u7684\u5c0f\u7a0b\u5e8f"}
{"task_id":"task/143","completion":"\n\n7. for element in li:\n\n8. yield element\n\ndef permutations(li):\n\n9. for i in range(len(li)):\n\n10. for j in range(i+1, len(li)):\n\n11. yield li[i], li[j]\n\n"}
{"task_id":"task/143","completion":"\n\nx = set()\n\nfor elem in li:\n\nif elem not in x:\n\nx.add(elem)\n\nreturn x\n\ndef unique_words(ws):\n\nx = set()\n\nfor w in ws:\n\nif w not in x:\n\nx"}
{"task_id":"task/143","completion":"\n\nunique_elements = []\n\nfor elem in li:\n\nif elem not in unique_elements:\n\nunique_elements.append(elem)\n\nreturn unique_elements\n\n\ndef unique_words(x):\n\nunique_words = []\n\nfor word in x:"}
{"task_id":"task/144","completion":"\n\n\"\"\"Convert RGB color to #RRGGBB format\"\"\"\n\nreturn r + r * 6 , g + g * 6 , b + b * 6\n\ndef is_palette_only(image):\n\n\"\"\"Determine if image is in the palette format\"\"\"\n\nreturn image.find('\\xff"}
{"task_id":"task/144","completion":" return (r << 16) + (g << 8) + b def hex_to_rgb(hex): return (hex >> 16) & 0xFF, (hex >> 8) & 0xFF, hex & 0xFF # The formula to convert an RGBA color to an HTML named color, # or to convert a"}
{"task_id":"task/144","completion":"\n\n\"\"\"Convert RGB values to hex string.\n\n\"\"\"\n\nreturn '#%02x%02x%02x' % (int(r*255), int(g*255), int(b*255))\n\ndef rgb_to_rgb(r, g, b):\n\n\"\"\"Convert"}
{"task_id":"task/144","completion":"\n\n'''Convert an RGB color to a hex string'''\n\nif r > 255 or g > 255 or b > 255:\n\nraise ValueError('rgb value out of range: %r' % (r,))\n\nhexstr = '#'\n\nif r > g > b:\n\n"}
{"task_id":"task/144","completion":"\n\n\"\"\"Returns hex color code for given RGB values\"\"\"\n\nreturn \" %02x%02x%02x \" % (r, g, b)\n\ndef parse_s3_bucket(s3_bucket):\n\n\"\"\"Converts S3 bucket name to lowercase and returns object dict\"\"\"\n\n"}
{"task_id":"task/145","completion":"\n\n\"\"\"\n\nThis method returns a flattened dict, for example dict(a=1, b=2) -> {'a': 1, 'b': 2}\n\n\"\"\"\n\nflat_dict = {}\n\nfor (k, v) in flat_dict.items():\n\nflat_dict[k] ="}
{"task_id":"task/145","completion":" flat_dict = flat_dict.copy() return flat_dict.values() # This just builds a dictionary that is two entries # longer than the value of the max_flat_dict_len max_flat_dict_len = 10 # This builds the dictionary to use for the flat dictionary # and then flattens it. flat_"}
{"task_id":"task/145","completion":"\n\n# Convert flat dict to list of unique values\n\nflat_dict_values = []\n\nfor item in flat_dict:\n\nflat_dict_values.append(item)\n\nreturn flat_dict_values\n\ndef get_values_only(flat_dict):\n\n# Use values_only to"}
{"task_id":"task/145","completion":" if not flat_dict.get('last_update', None): return flat_dict return flat_dict def compare_dicts(test_dict, target_dict): for key, value in test_dict.items(): if value != target_dict[key]: return False return True def test_all_dicts(self):"}
{"task_id":"task/145","completion":" \"\"\"Return only the values from a flat dict\"\"\" values = flat_dict.values() if values: return values else: return [] def filter_dict(d, func): \"\"\"Return a copy of a dict, without values that fail a test\"\"\" if type(d) is dict: d = {} else: assert type(d) is"}
{"task_id":"task/146","completion":"\n\n\"\"\"Get a generator that computes items in the cartesian product.\n\nArgs:\n\nfn: function that returns an item of the cartesian product.\n\nseed: an item of the cartesian product.\n\nReturns:\n\nA generator that yields all items of the cartesian product.\n\n\"\"\"\n\n"}
{"task_id":"task/146","completion":" # The stack is [seed, fn()] def visit(x): return fn(x) if x else x return visit for i in range(2): # i = 1 means the original [seed, fn()] list = [seed, i, seed] stack.append(list) stack.pop() print(stack.pop"}
{"task_id":"task/146","completion":"\n\n# Binary search to find the insertion point.\n\n# (Note that this *starts* at the end of the list.)\n\npos = len(self) - 1\n\nwhile pos >= 0:\n\nkey = (seed ^ self[pos]) & (2 ** 32 - 1)\n\nif key in"}
{"task_id":"task/146","completion":"\n\nreturn (fn(seed), fn(seed))\n\n\ndef insert(x):\n\nyield x\n\ndef h(s):\n\ns.append(x)\n\ns.append(y)\n\nreturn s\n\n\ndef f(n):\n\ndef f0(m):\n\nf1"}
{"task_id":"task/146","completion":"\n\n719 return (mul(fn, seed), add(mul(fn, seed), seed))\n\n720 # Defining an initial state\n\n721 def initial_state(seed):\n\n722 return (seed, seed)\n\n723 # Defining a final state\n\n724 def final"}
{"task_id":"task/147","completion":"\n\nglobal alpha\n\nif not alpha:\n\nalpha = len(itr)\n\nfor n in range(alpha, 0, -1):\n\nitr[n] = itr[0:n]\n\nreturn itr\n\n\ndef main():\n\nlist = [1,2,3,4"}
{"task_id":"task/147","completion":"\n\nreturn [value for value in itr]\n\n# Finalize the list of rules\n\nreturn rules\n\n\n\ndef generate_string(rules):\n\n\"\"\" Generator function that returns a string \"\"\"\n\nfor rule in rules:\n\nyield rule\n\n\n\ndef main():\n\nrules = generate_rules("}
{"task_id":"task/147","completion":"\n\n\"\"\"given a list returns a reversed copy of it\"\"\"\n\nif not isinstance(itr, list):\n\nreturn [itr]\n\nreturn [x for x in itr[::-1]]\n\n\n\ndef count_odds(itr):\n\n\"\"\"counts the number of odds in a"}
{"task_id":"task/147","completion":"\n\n- \"\"\"Return an iterator to the last index of the reversed iterator.\n\n- \"\"\"\n\n- for x in itr:\n\n- yield x\n\n- return itr\n\n-\n\n-class Queue:\n\n- \"\"\"A queue class.\n\n- A queue is a first-in-first"}
{"task_id":"task/147","completion":"\n\nfor i in range(len(itr)):\n\nif itr[i] < itr[i-1]:\n\nitr[i], itr[i-1] = itr[i-1], itr[i]\n\nreturn itr\n\n\n\n# main method\n\nif"}
{"task_id":"task/148","completion":" divisor = divisor.lower() return dividend % divisor == 0\n\nThe is_divisible function compares the remainder of dividing the first argument by the second argument, and returns True if the result is 0, and False otherwise.\n\nSee the section if Statement for a description of the if statement, and the section"}
{"task_id":"task/148","completion":"\n\n\"\"\"\n\ndividend and divisor are ints\n\ndividend is not 0\n\ndivisor is not 0\n\n\"\"\"\n\nreturn True\n\n\"\"\"\n\nSquare root\n\nhttps://docs.python.org/2/library/math.html#math.sqrt\n\nhttp"}
{"task_id":"task/148","completion":" \"\"\"Return True if the divisor is divisible by the dividend\"\"\" while divisor > 0: if dividend % divisor == 0: return True divisor = divisor - 1 return False\n\nIt's also possible to use the shorthand syntax of the ** operator if it's clear from the code that the argument is"}
{"task_id":"task/148","completion":" return (dividend % divisor) == 0 def is_multiple(dividend, divisor): return ((dividend % divisor) == 0) and (dividend == divisor * int(dividend / divisor)) for term in terms: for factor in factors: if factor"}
{"task_id":"task/148","completion":"\n\nif dividend % divisor == 0:\n\nreturn True\n\nelse:\n\nreturn False\n\n\n\nif __name__ == '__main__':\n\nimport sys\n\nif sys.version_info[0] == 2:\n\nprint \"2.x version\"\n\nelse:\n\nprint"}
{"task_id":"task/149","completion":"\n\nreturn d.day >= 5 and d.day <= 2\n\nif __name__ == '__main__':\n\nimport sys\n\nif len(sys.argv) != 2:\n\nprint(\"USAGE:\", sys.argv[0], \"URL\")\n\nexit(1)\n\nurl"}
{"task_id":"task/149","completion":"\n\nreturn d.weekday() in [0, 6]\n\ndef is_weekend(d = datetime.today()):\n\nreturn d.weekday() in [6, 0]\n\n\"\"\"\n\ndef _date_time_from_datetime ( dt ):\n\nimport _date_time"}
{"task_id":"task/149","completion":"\n\nif d.weekday() == 5:\n\nreturn True\n\nelse:\n\nreturn False\n\nif __name__ == \"__main__\":\n\nprint is_weekday(datetime.today())\n\nprint is_weekday(datetime.today() + timedelta(days=1))\n"}
{"task_id":"task/149","completion":"\n\ns = d.strftime('%A')\n\nreturn s.startswith('Mon') or s.startswith('Tue') or s.startswith('Wed') or s.startswith('Thu') or s.startswith('Fri') or s.startswith('Sat') or s"}
{"task_id":"task/149","completion":"\n\nif (d.weekday() == 0):\n\nreturn False\n\nreturn True\n\nWhen it comes to the actual testing itself, we\u2019ll use the core unittest module and have a number of tests we want to check for. For this, we\u2019ll also have to write a number of helper functions"}
{"task_id":"task/150","completion":"\n\nreturn degrees - 32.0\n\nExample:\n\n>>> print(fahrenheit_to_celsius(100)) 50.0 >>> print(fahrenheit_to_celsius(200)) 100.0 >>> print(fahrenheit_to_celsius(250)) 150.0 >>> print"}
{"task_id":"task/150","completion":"\n\nreturn (degrees - 32) * 5 / 9\n\n\n\ndef convert_to_celsius(fahrenheit):\n\nreturn fahrenheit_to_celsius(fahrenheit)\n\n\n\nfahrenheit = input(\"Enter a temperature in Fahrenheit: \")\n\ncelsius = convert"}
{"task_id":"task/150","completion":" \"\"\"Convert Fahrenheit degrees to Celsius.\"\"\" return degrees * 1.8 + 32\n\nThe name of a function can be anything you want, as long as it obeys the rules for identifiers (see the sidebar).\n\nArguments and Parameters\n\nFunctions are called by writing the function\u2019s name followed by a list of"}
{"task_id":"task/150","completion":" \"\"\"Given a number of degrees in Fahrenheit, return the number of degrees in Celsius.\"\"\" return degrees * (5.0/9.0) + 32.0\n\nIf you are familiar with C or C++, you can think of the return statement as an early return from a function. The equivalent of the return statement in C is"}
{"task_id":"task/150","completion":" # degrees is the number of degrees Fahrenheit to convert. return (degrees-32)*5/9.0 def celsius_to_fahrenheit(celsius): # celsius is the number of degrees Celsius to convert. return (celsius*9/5.0)+32\n\nThese functions do a good job"}
{"task_id":"task/151","completion":"\n\nreturn reduce(lambda a, b: a + b, lst, 0)\n\nprint(sum_by([2, 3, 1, 4, 7, 8], sum))\n\n\nIn the preceding example, we have a function sum_by, which takes a list and a function as an argument. This function can"}
{"task_id":"task/151","completion":" total = 0 for value in lst: total += fn(value) return total\n\nIn the first example, the programmer is thinking about what is necessary to perform the task. In the second example, the programmer is thinking about the properties of the task itself.\n\nNow, let's look at the class to see how it works."}
{"task_id":"task/151","completion":"\n\nreturn reduce(lambda x, y: x + y, lst, 0)\n\nprint(sum_by([1,2,3,4,5], lambda x: x**2))\n\nprint(sum_by([1,2,3,4,5], lambda x: x**2, 0"}
{"task_id":"task/151","completion":" return reduce(lambda x, y: x + y, lst, 0)\n\nThis is a tail-recursive implementation of a sum. So, if we pass a list of numbers, it will add them up and return the result.\n\n>>> sum_by([1, 2, 3, 4, 5], lambda x"}
{"task_id":"task/151","completion":"\n\nret = 0\n\nfor e in lst:\n\nret += fn(e)\n\nreturn ret\n\nIn Python, the lambda is implemented using the def keyword. The first argument, lst, is the name of the list. The second argument, fn, is the name of the function.\n\nThe lambda"}
{"task_id":"task/152","completion":" return val in dict\n\ndef find_key_exists(dict, val): return find_key(dict, val) != -1\n\n# \"Set\" operations\n\ndef add(set, val):\n\nreturn set.add(val)\n\ndef remove(set, val):\n\nreturn set.remove"}
{"task_id":"task/152","completion":"\n\n\"\"\"\n\nReturns True if a key exists, otherwise False.\n\n\"\"\"\n\nfor key in sorted(dict.keys()):\n\nif dict[key] == val:\n\nreturn True\n\nreturn False\n\n\ndef create_random_sorted_dict(min_length, max_length):\n\n"}
{"task_id":"task/152","completion":"\n\nfor key in sorted(dict.keys()):\n\nif key == val:\n\nreturn key\n\nreturn None\n\n\ndef find_in_keys(dict, val):\n\nfor key in sorted(dict.keys()):\n\nif key == val:\n\nreturn key\n\nreturn None\n\n\ndef"}
{"task_id":"task/152","completion":"\n\n\"\"\"\n\nFind the key in the dictionary that matches the given value.\n\nIf the value is not a key in the dictionary, raise a KeyError.\n\n\"\"\"\n\nif val in dict:\n\nreturn dict[val]\n\nelse:\n\nraise KeyError('Key \\'%s\\' not found'"}
{"task_id":"task/152","completion":"\n\nfor key in dict:\n\nif key == val:\n\nreturn key\n\nreturn None\n\n\ndef print_key(dict, key):\n\nprint key, 'is not found in', dict\n\n\nif __name__ == '__main__':\n\nd = {'spam': 'lunch',"}
{"task_id":"task/153","completion":"\n\n\"\"\"\n\nConvert a number to a four-digit base-16 number in hexadecimal.\n\n\"\"\"\n\nreturn ' { :04x } ' .format(dec)\n\ndef to_octal(dec):\n\n\"\"\"\n\nConvert a number to a three-digit base-8 number"}
{"task_id":"task/153","completion":"\n\nreturn '{:04x}'.format(dec)\n\n\ndef hex(num):\n\nreturn '{:02x}'.format(num)\n\n\ndef word2num(s):\n\nreturn len(s) * 2 + ord(s[0])\n\n\ndef num2word(n):\n"}
{"task_id":"task/153","completion":" return \"0x%x\" % dec\n\n+\n\n+ #\n\n+ # It is assumed that the given bytes do NOT have a 0x00 prefix\n\n+ #\n\n+\n\n+ # Convert the ascii hex string in hex to a byte sequence with\n\n+ # binary representation in hex.\n"}
{"task_id":"task/153","completion":"\n\n\"\"\"Convert to hexadecimal number string.\"\"\"\n\nif dec < 0:\n\nraise ValueError(\"Non-numeric value: %s\" % dec)\n\nelif dec == 0:\n\nreturn \"0\"\n\nreturn str(dec)[2:]\n\n\n\nclass LPLayer("}
{"task_id":"task/153","completion":" return dec.encode('hex') To convert to an int, use the int() function: >>> int(to_hex(11234)) 11234 The bytes module has more functions for working with binary data. For example, to pad a number with zeros on the left, use the bytes.pad() function: >>> import bytes >>>"}
{"task_id":"task/154","completion":" return a if num < a else b\n\nWhen you run the above code, it prints:\n\n9 5\n\nAs expected. But what about the following:\n\n>>> def clamp_number(num, a, b): return b if num > b else a\n\nIt also prints:\n\n9 5\n\nThis"}
{"task_id":"task/154","completion":" if num < a: return a if num > b: return b return num def is_prime(num): if num < 2: return False elif num % 2 == 0: return False if num == 2: return True for i in range(3, int(math.sqrt(num)) + 1, 2): if num"}
{"task_id":"task/154","completion":"\n\nif num < a:\n\nreturn a\n\nelif num > b:\n\nreturn b\n\nelse:\n\nreturn num\n\n\n\ndef clamp_length(num, a, b):\n\nif num < a:\n\nreturn a\n\nelif num > b:\n\nreturn b\n\n"}
{"task_id":"task/154","completion":" if num > b: return b if num < a: return a else: return num\n\nHere, the function takes two arguments (a and b) and returns a single number. The function is a one-to-one map from the domain to the range. If either of the arguments are null, then the result will be null."}
{"task_id":"task/154","completion":"\n\nassert a <= b\n\nreturn num\n\ndef clamp_value(value, a, b):\n\nassert a <= b\n\nreturn value\n\n\"\"\"\n\ndef clamp ( value , min_value , max_value ):\n\nif max_value is None :\n\nmax_value = min_value\n"}
{"task_id":"task/155","completion":"\n\nr = reduce(lambda x, y: x(y), fns, None)\n\nreturn r(None)\n\n# create a new decorator, @approximate, which calls the decorated function\n\n# with the provided tolerance and returns the result\n\n@approximate(1e-7)\n"}
{"task_id":"task/155","completion":"\n\nreturn reduce(lambda x, y: x(y), fns, None)\n\nThe classic use case for this is to define a new function that calls multiple others, where you have no use for the return value from any of the functions. As an example, suppose we wanted to generate a new random number each time we call"}
{"task_id":"task/155","completion":"\n\n\"\"\"compose fns right to left\"\"\"\n\n# XXX make clear how to handle the case of different\n\n# arities\n\nfns = [reduce(lambda x, y: x(y)(*fns[-1])(*fns[:-1]))]\n\nreturn reduce(lambda"}
{"task_id":"task/155","completion":"\n\n\"\"\"\n\nReturn a fn that is the right composition of a list of fns.\n\n\"\"\"\n\nreturn reduce(lambda f, g: lambda x: f(g(x)), fns, lambda x: x)\n\n# The original source of this reduction is unknown.\n\ndef curry(f, *"}
{"task_id":"task/155","completion":"\n\n#print \"composing fns\"\n\nresult = fns[-1](fns[-2](*fns[-3:]))\n\nreturn reduce(operator.add, fns, result)\n\n#sum [1,2,3] = reduce(operator.add, [1,2"}
{"task_id":"task/156","completion":"\n\n\"\"\"Calculate the number of days between two datetime.datetime\n\nobjects.\n\n\"\"\"\n\nreturn (end - start).days\n\ndef get_day_in_year(year, month, day):\n\n\"\"\"Calculate the day of the year from a given date.\"\"\"\n\n#"}
{"task_id":"task/156","completion":" end = time.mktime(end.timetuple()) return (end - start).days def get_projected_dates(metric, window_size, date_key=None): start = None end = None if date_key is None: date_key = get_date_key(metric, window_size"}
{"task_id":"task/156","completion":" \"\"\" Finds the number of days difference between two datetime objects \"\"\" d1 = datetime.datetime(start.year, start.month, start.day) d2 = datetime.datetime(end.year, end.month, end.day) return d2 - d1.date() - d1.days"}
{"task_id":"task/156","completion":" diff = end - start if diff < 0: return \"in the future\" elif diff == 0: return \"today\" elif diff < 60: return str(diff).zfill(2) + \" minute\" elif diff < 3600: return str(diff/60).zfill(2) + \" hour\" el"}
{"task_id":"task/156","completion":"\n\nstart = datetime.datetime.utcfromtimestamp(start)\n\nend = datetime.datetime.utcfromtimestamp(end)\n\nd = timedelta(days=end-start)\n\nreturn d.days\n\ndef box_remove_excessive_whitespace(text"}
{"task_id":"task/157","completion":" # A and B must be sets. # If they are the same set, they are contained in each other. if a == b: return True # elif they have different sizes, then there are items # in a that are not in b, and vice versa. return a.size != b.size # elif a is a proper"}
{"task_id":"task/157","completion":" # Your code here return 0\n\n\u8fd9\u4e2a\u51fd\u6570\u7684\u529f\u80fd\u662f\u5224\u65ad\u4e00\u4e2a\u6570\u662f\u5426\u5c5e\u4e8e\u53e6\u4e00\u4e2a\u6570\u7ec4\u4e2d\uff0c\u4e0b\u9762\u662f\u4f7f\u7528\u8fd9\u4e2a\u51fd\u6570"}
{"task_id":"task/157","completion":"\n\nreturn (a < b) and (b < a)\n\n\ndef contains(a, b):\n\nreturn is_contained_in(a, b)\n\n\ndef coverage(a, b):\n\nreturn a < b and not is_contained_in(a, b)\n\n\ndef is_overl"}
{"task_id":"task/157","completion":" return a.contains(b) or b.contains(a) or a == b or b == a or a.is_subset_of(b) or b.is_subset_of(a)\n\nThe definition above uses the or operator. This is the right thing to do if you have to decide"}
{"task_id":"task/157","completion":"\n\n\"\"\"Raises ValueError if `a` and `b` are disjoint sets.\"\"\"\n\nif not a.intersection(b) == None:\n\nraise ValueError('Cannot test containment in a disjoint set.')\n\nif not b.intersection(a) == None:\n\n"}
{"task_id":"task/158","completion":"\n\nif n == 1:\n\nreturn a\n\nelif n % 2 == 0:\n\nreturn a + a\n\nelse:\n\nreturn a - a\n\n\n\n# 'seed' is just a simple list.\n\n# return the first element of 'seed'\n\ndef seed():\n\nreturn ["}
{"task_id":"task/158","completion":"\n\n+ \"\"\"Drop the rightmost n elements of a list.\n\n+\n\n+ >>> drop_right([1, 2, 3, 4, 5, 6, 7, 8])\n\n+ [1, 2, 3, 4, 5, 6, 7]\n\n+ \"\"\"\n\n+ return list(a"}
{"task_id":"task/158","completion":" for i in range(1, n): a = a[:i] + a[i+1:] return a\n\nThis version is the same as the version in the previous section, except that it uses two variables a and n and two loops instead of one.\n\nThe while loop is entered on line 4 and exited on line"}
{"task_id":"task/158","completion":"\n\nif (a.endswith('0') and len(a) > n):\n\nreturn a[:n] + '0' + a[-n:]\n\nelse:\n\nreturn a\n\n\ndef drop_left(a, n = 1):\n\nif (a.endswith('0"}
{"task_id":"task/158","completion":"\n\n\"\"\"Drop rightmost `n` elements of `a`.\"\"\"\n\nreturn a[n:]\n\n\n\ndef drop_right_same(a, n = 1):\n\n\"\"\"Drop rightmost `n` elements of `a` preserving order.\"\"\"\n\nreturn a[:n] + a[n:]"}
{"task_id":"task/159","completion":"\n\ndef lcm(numbers):\n\ndef factors(number):\n\ndef first_prime(number):\n\ndef is_prime(number):\n\ndef is_divisible_by(number, divisor):\n\ndef is_palindrome(number):\n\ndef is_perfect_square("}
{"task_id":"task/159","completion":"\ndef is_prime(n):\ndef count_prime(numbers):\ndef make_divisor(n):\ndef print_lcm(numbers):\ndef print_sums(numbers):\ndef print_sums_with_remainder(numbers):\ndef same_cardinality"}
{"task_id":"task/159","completion":"\n\ndef is_prime(n):\n\ndef is_palindrome(n):\n\ndef generate_palindromes(n):\n\ndef generate_palindromes_between(n, start, end):\n\ndef generate_palindromes_below(n, start, end):\n\n"}
{"task_id":"task/159","completion":"\n\ndef prime_factors(numbers):\n\n# Raises an error if numbers contains two or more pairs of factors.\n\ndef gcd_factors(numbers):\n\ndef divisors(numbers):\n\ndef divisor_sum(numbers):\n\ndef divisor_sum"}
{"task_id":"task/159","completion":"\n\nThe following lines give the definition of the private methods _lt (less than) and _le (less than or equal). The first one returns 1 when the first parameter is smaller than the second one, 0 otherwise. The second one returns 1 when the first parameter is smaller than or equal to the second one, 0 otherwise.\n\n"}
