{"task_id":"task/1","prompt":"import \"fmt\"\n\nfunc PadRight(s string, l int) string {","canonical_solution":"\tf := \"%\" + strconv.Itoa(-l) + \"v\"\n\treturn fmt.Sprintf(f, s)\n}","entry_point":"PadRight","test":"PadRight(\"go\", 8) // \"go      \""}
{"task_id":"task/2","prompt":"import (","canonical_solution":"\t\"math\"\n\t\"sort\"\n)\n\nfunc Median(nums ...float64) float64 {\n\tm, n := int(math.Floor(float64(len(nums))/2.0)),\n\t\tnums[:]\n\tsort.Float64s(n)\n\n\tif len(nums)%2 == 0 {\n\t\treturn (n[m] + n[m+1]) / 2.0\n\t}\n\treturn n[m]\n}","entry_point":"Median","test":"Median(5.0, 6.0, 50.0, 1.0, -5.0) // 5.0"}
{"task_id":"task/3","prompt":"import \"math/rand\"\n\nfunc RandIntSliceInRange(min, max, n int) []int {","canonical_solution":"\tarr := make([]int, n)\n\n\tfor i := range arr {\n\t\tarr[i] = rand.Intn(max-min) + min\n\t}\n\treturn arr\n}","entry_point":"RandIntSliceInRange","test":"RandIntSliceInRange(12, 35, 10) // [19 34 29 15 25 21 18 23 32 27]"}
{"task_id":"task/4","prompt":"import \"strings\"\n\nfunc ToSnake(s string) string {","canonical_solution":"\treturn strings.Join(strings.Fields(s), \"_\")\n}","entry_point":"ToSnake","test":"ToSnake(\"some text\") // \"some_text\""}
{"task_id":"task/5","prompt":"func FilterInt(arr []int, f func(int) bool) []int {","canonical_solution":"\tarf := make([]int, 0)\n\tfor _, v := range arr {\n\t\tif f(v) {\n\t\t\tarf = append(arf, v)\n\t\t}\n\t}\n\treturn arf\n}\nfunc FilterFloat64(arr []float64, f func(float64) bool) []float64 {\n\tarf := make([]float64, 0)\n\tfor _, v := range arr {\n\t\tif f(v) {\n\t\t\tarf = append(arf, v)\n\t\t}\n\t}\n\treturn arf\n}\nfunc FilterBool(arr []bool, f func(bool) bool) []bool {\n\tarf := make([]bool, 0)\n\tfor _, v := range arr {\n\t\tif f(v) {\n\t\t\tarf = append(arf, v)\n\t\t}\n\t}\n\treturn arf\n}\nfunc FilterString(arr []string, f func(string) bool) []string {\n\tarf := make([]string, 0)\n\tfor _, v := range arr {\n\t\tif f(v) {\n\t\t\tarf = append(arf, v)\n\t\t}\n\t}\n\treturn arf\n}","entry_point":"Filter","test":"intCheck := func(x int) bool { return x > 1 }\nFilterInt([]int{0, 2}, intCheck) // [2]\nfloat64Check := func(x float64) bool { return x > 0.5 }\nFilterFloat64([]float64{0.0, 1.0}, float64Check) // [1.0]\nboolCheck := func(x bool) bool { return x }\nFilterBool([]bool{false, true}, boolCheck) // [true]\nstringCheck := func(x string) bool { return len(x) > 1 }\nFilterString([]string{\"\", \"hi\"}, stringCheck) // [\"hi\"]"}
{"task_id":"task/6","prompt":"import \"fmt\"\n\nfunc FindInt(arr []int, f func(int) bool) (int, error) {","canonical_solution":"\tfor _, v := range arr {\n\t\tif f(v) {\n\t\t\treturn v, nil\n\t\t}\n\t}\n\treturn 0, fmt.Errorf(\"No matches found\")\n}\nfunc FindFloat64(arr []float64, f func(float64) bool) (float64, error) {\n\tfor _, v := range arr {\n\t\tif f(v) {\n\t\t\treturn v, nil\n\t\t}\n\t}\n\treturn 0.0, fmt.Errorf(\"No matches found\")\n}\nfunc FindBool(arr []bool, f func(bool) bool) (bool, error) {\n\tfor _, v := range arr {\n\t\tif f(v) {\n\t\t\treturn v, nil\n\t\t}\n\t}\n\treturn false, fmt.Errorf(\"No matches found\")\n}\nfunc FindString(arr []string, f func(string) bool) (string, error) {\n\tfor _, v := range arr {\n\t\tif f(v) {\n\t\t\treturn v, nil\n\t\t}\n\t}\n\treturn \"\", fmt.Errorf(\"No matches found\")\n}","entry_point":"Find","test":"FindInt([]int{1, 1, 2}, func(x int) bool { return x%2 == 0 }) // 2 nil\nFindFloat64([]float64{4.0, 6.0}, func(x float64) bool { return x%2.0 == 1.0 }) // 0.0 \"No matches found\""}
{"task_id":"task/7","prompt":"func gcd(x, y int) int {","canonical_solution":"\tif y == 0 {\n\t\treturn x\n\t}\n\treturn gcd(y, x%y)\n}\n\nfunc LCM(nums ...int) int {\n\tx := nums[0]\n\tfor _, y := range nums[1:] {\n\t\tx = (x * y) / gcd(x, y)\n\t}\n\treturn x\n}","entry_point":"LCM","test":"LCM(12, 7) // 84\nLCM([]int{1, 3, 4, 5}...) // 60"}
{"task_id":"task/8","prompt":"import \"math\"\n\nfunc Clamp(n, a, b float64) float64 {","canonical_solution":"\treturn math.Max(math.Min(n, math.Max(a, b)), math.Min(a, b))\n}","entry_point":"Clamp","test":"Clamp(2.0, 3.0, 5.0) // 3.0\nClamp(1.0, -1.0, -5.0) // -1.0"}
{"task_id":"task/9","prompt":"import \"reflect\"\n\nfunc Zip(params ...interface{}) [][]interface{} {","canonical_solution":"\tl := 0\n\tfor i := range params {\n\t\tarr := reflect.ValueOf(params[i])\n\t\tif l < arr.Len() {\n\t\t\tl = arr.Len()\n\t\t}\n\t}\n\tr := make([][]interface{}, l)\n\n\tfor i := 0; i < l; i++ {\n\t\tr[i] = make([]interface{}, 0)\n\t\tfor j := range params {\n\t\t\tv := reflect.ValueOf(params[j])\n\t\t\tif v.Len() > i {\n\t\t\t\tr[i] = append(r[i], v.Index(i).Interface())\n\t\t\t}\n\t\t}\n\t}\n\treturn r\n}","entry_point":"Zip","test":"s := []string{\"a\", \"b\"}\ni := []int{1, 2}\nb := []bool{true, false}\nZip(s, i, b) // [[a 1 true] [b 2 false]]"}
{"task_id":"task/10","prompt":"import \"fmt\"\n\nfunc PadLeft(s string, l int) string {","canonical_solution":"\tf := \"%\" + strconv.Itoa(l) + \"v\"\n\treturn fmt.Sprintf(f, s)\n}","entry_point":"PadLeft","test":"PadLeft(\"go\", 8) // \"      go\""}
{"task_id":"task/11","prompt":"func MapInt(arr []int, fn func(int) int) []int {","canonical_solution":"\tarm := make([]int, len(arr))\n\tfor i, v := range arr { arm[i] = fn(v) }\n\treturn arm\n}\nfunc MapIntFloat64(arr []int, fn func(int) float64) []float64 {\n\tarm := make([]float64, len(arr))\n\tfor i, v := range arr { arm[i] = fn(v) }\n\treturn arm\n}\nfunc MapIntBool(arr []int, fn func(int) bool) []bool {\n\tarm := make([]bool, len(arr))\n\tfor i, v := range arr { arm[i] = fn(v) }\n\treturn arm\n}\nfunc MapIntString(arr []int, fn func(int) string) []string {\n\tarm := make([]string, len(arr))\n\tfor i, v := range arr { arm[i] = fn(v) }\n\treturn arm\n}\n\nfunc MapFloat64(arr []float64, fn func(float64) float64) []float64 {\n\tarm := make([]float64, len(arr))\n\tfor i, v := range arr { arm[i] = fn(v) }\n\treturn arm\n}\nfunc MapFloat64Int(arr []float64, fn func(float64) int) []int {\n\tarm := make([]int, len(arr))\n\tfor i, v := range arr { arm[i] = fn(v) }\n\treturn arm\n}\nfunc MapFloat64Bool(arr []float64, fn func(float64) bool) []bool {\n\tarm := make([]bool, len(arr))\n\tfor i, v := range arr { arm[i] = fn(v) }\n\treturn arm\n}\nfunc MapFloat64String(arr []float64, fn func(float64) string) []string {\n\tarm := make([]string, len(arr))\n\tfor i, v := range arr { arm[i] = fn(v) }\n\treturn arm\n}\n\nfunc MapBool(arr []bool, fn func(bool) bool) []bool {\n\tarm := make([]bool, len(arr))\n\tfor i, v := range arr { arm[i] = fn(v) }\n\treturn arm\n}\nfunc MapBoolInt(arr []bool, fn func(bool) int) []int {\n\tarm := make([]int, len(arr))\n\tfor i, v := range arr { arm[i] = fn(v) }\n\treturn arm\n}\nfunc MapBoolFloat64(arr []bool, fn func(bool) float64) []float64 {\n\tarm := make([]float64, len(arr))\n\tfor i, v := range arr { arm[i] = fn(v) }\n\treturn arm\n}\nfunc MapBoolString(arr []bool, fn func(bool) string) []string {\n\tarm := make([]string, len(arr))\n\tfor i, v := range arr { arm[i] = fn(v) }\n\treturn arm\n}\n\nfunc MapString(arr []string, fn func(string) string) []string {\n\tarm := make([]string, len(arr))\n\tfor i, v := range arr { arm[i] = fn(v) }\n\treturn arm\n}\nfunc MapStringInt(arr []string, fn func(string) int) []int {\n\tarm := make([]int, len(arr))\n\tfor i, v := range arr { arm[i] = fn(v) }\n\treturn arm\n}\nfunc MapStringFloat64(arr []string, fn func(string) float64) []float64 {\n\tarm := make([]float64, len(arr))\n\tfor i, v := range arr { arm[i] = fn(v) }\n\treturn arm\n}\nfunc MapStringBool(arr []string, fn func(string) bool) []bool {\n\tarm := make([]bool, len(arr))\n\tfor i, v := range arr { arm[i] = fn(v) }\n\treturn arm\n}","entry_point":"Map","test":"import \"fmt\"\n\nints := []int{1, 2, 3}\naddTwo := func(x int) int { return x + 2 }\ndollarString := func(x int) string { return fmt.Sprintf(\"$%d\", x) }\nMapInt(ints, addTwo) // [3 4 5]\nMapIntString(ints, dollarString) // [\"$1\" \"$2\" \"$3\"]\n\nfloats := []float64{3.0, 2.0, 0.0}\ngtTwo := func(x float64) bool { return x > 2.0 }\nMapFloat64Bool(floats, gtTwo) // [true false false]\n\nstrings := []string{\"go\", \"is\", \"cool\"}\nstrLen := func(x string) int { return len(x) }\nMapStringInt(strings, strLen) // [2 2 4]"}
{"task_id":"task/12","prompt":"import \"regexp\"\n\nfunc CompactWhiteSpace(str string) string {","canonical_solution":"\tre := regexp.MustCompile(`\\s{2,}`)\n\treturn re.ReplaceAllString(str, \" \")\n}","entry_point":"CompactWhiteSpace","test":"CompactWhiteSpace(\"Lorem    Ipsum\") // \"Lorem Ipsum\"\nCompactWhiteSpace(\"Lorem \\n Ipsum\") // \"Lorem Ipsum\""}
{"task_id":"task/13","prompt":"func IsPowerOf2(n int) bool {","canonical_solution":"\treturn n > 0 && (n&(n-1)) == 0\n}","entry_point":"IsPowerOf2","test":"IsPowerOf2(0) // false\nIsPowerOf2(1) // true\nIsPowerOf2(8) // true"}
{"task_id":"task/14","prompt":"import \"strings\"\n\nfunc Capitalize(s string) string {","canonical_solution":"\treturn strings.ToUpper(s[0:1]) + s[1:]\n}","entry_point":"Capitalize","test":"Capitalize(\"boomerang\") // \"Boomerang\""}
{"task_id":"task/15","prompt":"func TruncateString(s string, l int) string {","canonical_solution":"\tr := s\n\tif len(s) > l {\n\t\tif l > 3 {\n\t\t\tl -= 3\n\t\t}\n\t\tr = s[0:l] + \"...\"\n\t}\n\treturn r\n}","entry_point":"TruncateString","test":"TruncateString(\"boomerang\", 7); // \"boom...\""}
{"task_id":"task/16","prompt":"func IntRange(f, t, s int) []int {","canonical_solution":"\tarr := make([]int, (t-f+1)/s)\n\tfor i := range arr {\n\t\tarr[i] = i*s + f\n\t}\n\treturn arr\n}","entry_point":"IntRange","test":"IntRange(0, 9, 2) // [0 2 4 6 8]"}
{"task_id":"task/17","prompt":"import \"math\"\n\nfunc IsInRange(n, a, b float64) bool {","canonical_solution":"\ts, e := math.Min(a, b), math.Max(a, b)\n\treturn n >= s && n < e\n}","entry_point":"IsInRange","test":"IsInRange(3, 2, 5) // true\nIsInRange(2, 3, 5) // false"}
{"task_id":"task/18","prompt":"import \"reflect\"\n\nfunc IndexOf(params ...interface{}) int {","canonical_solution":"\tarr, v := reflect.ValueOf(params[0]),\n\t\treflect.ValueOf(params[1]).Interface()\n\n\tfor i := 0; i < arr.Len(); i++ {\n\t\tif arr.Index(i).Interface() == v {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}","entry_point":"IndexOf","test":"IndexOf([]int{1, 2, 3}, 2) // 1\nIndexOf([]int{1, 2, 3}, 4) // -1"}
{"task_id":"task/19","prompt":"import \"strings\"\n\nfunc ToKebab(s string) string {","canonical_solution":"\treturn strings.Join(strings.Fields(s), \"-\")\n}","entry_point":"ToKebab","test":"ToKebab(\"some text\") // \"some-text\""}
{"task_id":"task/20","prompt":"func FrequenciesInt(arr []int) map[int]int {","canonical_solution":"\tm := make(map[int]int)\n\tfor _, v := range arr {\n\t\tif f, ok := m[v]; ok {\n\t\t\tm[v] = f + 1\n\t\t} else {\n\t\t\tm[v] = 1\n\t\t}\n\t}\n\treturn m\n}\nfunc FrequenciesFloat64(arr []float64) map[float64]int {\n\tm := make(map[float64]int)\n\tfor _, v := range arr {\n\t\tif f, ok := m[v]; ok {\n\t\t\tm[v] = f + 1\n\t\t} else {\n\t\t\tm[v] = 1\n\t\t}\n\t}\n\treturn m\n}\nfunc FrequenciesBool(arr []bool) map[bool]int {\n\tm := make(map[bool]int)\n\tfor _, v := range arr {\n\t\tif f, ok := m[v]; ok {\n\t\t\tm[v] = f + 1\n\t\t} else {\n\t\t\tm[v] = 1\n\t\t}\n\t}\n\treturn m\n}\nfunc FrequenciesString(arr []string) map[string]int {\n\tm := make(map[string]int)\n\tfor _, v := range arr {\n\t\tif f, ok := m[v]; ok {\n\t\t\tm[v] = f + 1\n\t\t} else {\n\t\t\tm[v] = 1\n\t\t}\n\t}\n\treturn m\n}","entry_point":"Frequencies","test":"MySnippet() // \"result\""}
{"task_id":"task/21","prompt":"import \"regexp\"\n\nfunc ContainsWhiteSpace(str string) bool {","canonical_solution":"\tre := regexp.MustCompile(`\\s`)\n\treturn re.MatchString(str)\n}","entry_point":"ContainsWhiteSpace","test":"ContainsWhiteSpace(\"lorem\") // false\nContainsWhiteSpace(\"lorem ipsum\") // true"}
{"task_id":"task/22","prompt":"func Sum(nums ...float64) float64 {","canonical_solution":"\tsum := float64(0)\n\tfor _, num := range nums {\n\t\tsum += num\n\t}\n\treturn sum\n}","entry_point":"Sum","test":"Sum(1.0, 4.0) // 5.0\nSum([]float64{1.0, 2.0, 3.0}...) // 6.0"}
{"task_id":"task/23","prompt":"import (","canonical_solution":"\t\"strconv\"\n\t\"strings\"\n)\n\nfunc Digits(n int) []int {\n\ts := strconv.Itoa(n)\n\td := make([]int, len(s))\n\tfor i, l := range strings.Split(s, \"\") {\n\t\td[i], _ = strconv.Atoi(l)\n\t}\n\treturn d\n}","entry_point":"Digits","test":"Digits(123) // [1 2 3]"}
{"task_id":"task/24","prompt":"import \"math/rand\"\n\nfunc RandIntInRange(min, max int) int {","canonical_solution":"\treturn rand.Intn(max-min) + min\n}","entry_point":"RandIntInRange","test":"RandIntInRange(0, 5) // 2"}
{"task_id":"task/25","prompt":"import \"strings\"\n\nfunc IsLower(s string) bool {","canonical_solution":"\treturn strings.ToLower(s) == s\n}","entry_point":"IsLower","test":"IsUpper(\"go\") // true\nIsUpper(\"Go\") // false"}
{"task_id":"task/26","prompt":"func Average(nums ...float64) float64 {","canonical_solution":"\tsum := float64(0)\n\tfor _, num := range nums {\n\t\tsum += num\n\t}\n\treturn sum / float64(len(nums))\n}","entry_point":"Average","test":"Average(1.0, 4.0) // 2.5\nAverage([]float64{1.0, 2.0, 3.0}...) // 2.0"}
{"task_id":"task/27","prompt":"import \"reflect\"\n\nfunc IndexOfAll(params ...interface{}) []int {","canonical_solution":"\tarr, v, r := reflect.ValueOf(params[0]),\n\t\treflect.ValueOf(params[1]).Interface(),\n\t\tmake([]int, 0)\n\n\tfor i := 0; i < arr.Len(); i++ {\n\t\tif arr.Index(i).Interface() == v {\n\t\t\tr = append(r, i)\n\t\t}\n\t}\n\tif len(r) != 0 {\n\t\treturn r\n\t}\n\treturn []int{-1}\n}","entry_point":"IndexOfAll","test":"IndexOfAll([]int{1, 2, 1, 3, 1, 1}, 1) // [0 2 4 5]\nIndexOfAll([]int{1, 2, 1, 3, 1, 1}, 4) // [-1]"}
{"task_id":"task/28","prompt":"func AnyInt(arr []int, fn func(int) bool) bool {","canonical_solution":"\tfor _, v := range arr {\n\t\tif fn(v) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\nfunc AnyFloat64(arr []float64, fn func(float64) bool) bool {\n\tfor _, v := range arr {\n\t\tif fn(v) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\nfunc AnyBool(arr []bool, fn func(bool) bool) bool {\n\tfor _, v := range arr {\n\t\tif fn(v) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\nfunc AnyString(arr []string, fn func(string) bool) bool {\n\tfor _, v := range arr {\n\t\tif fn(v) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}","entry_point":"Any","test":"intCheck := func(x int) bool { return x > 1 }\nAnyInt([]int{0, 2}, intCheck) // true\nfloat64Check := func(x float64) bool { return x > 0.5 }\nAnyFloat64([]float64{0.0, 1.0}, float64Check) // true\nboolCheck := func(x bool) bool { return x }\nAnyBool([]bool{false, true}, boolCheck) // true\nstringCheck := func(x string) bool { return len(x) > 1 }\nAnyString([]string{\"\", \"hi\"}, stringCheck) // true"}
{"task_id":"task/29","prompt":"func ReverseString(s string) string {","canonical_solution":"\to := make([]rune, len(s))\n\tfor i, c := range s {\n\t\to[len(s)-i-1] = c\n\t}\n\treturn string(o)\n}","entry_point":"ReverseString","test":"ReverseString(\"hello\") // \"olleh\""}
{"task_id":"task/30","prompt":"import \"strings\"\n\nfunc ToCamel(s string) string {","canonical_solution":"\tc := \"\"\n\tfor _, w := range strings.Fields(s) {\n\t\tc += strings.ToUpper(w[0:1]) + strings.ToLower(w[1:])\n\t}\n\treturn strings.ToLower(c[0:1]) + c[1:]\n}","entry_point":"ToCamel","test":"ToCamel(\"some text\") // \"someText\""}
{"task_id":"task/31","prompt":"import \"reflect\"\n\nfunc WithIndex(params ...interface{}) map[int]interface{} {","canonical_solution":"\tarr, m := reflect.ValueOf(params[0]),\n\t\tmake(map[int]interface{})\n\tfor i := 0; i < arr.Len(); i++ {\n\t\tm[i] = arr.Index(i).Interface()\n\t}\n\treturn m\n}","entry_point":"WithIndex","test":"WithIndex([]int{4, 3, 2, 1}) // [0:4 1:3 2:2 3:1]"}
{"task_id":"task/32","prompt":"import \"strings\"\n\nfunc Indent(s, i string) string {","canonical_solution":"\treturn i + strings.Replace(s, \"\\n\", \"\\n\"+i, -1)\n}","entry_point":"IndentString","test":"Indent(\"Lorem\\nIpsum\",\"_\") // \"_Lorem\\n_Ipsum\""}
{"task_id":"task/33","prompt":"func ConcatInt(a,b []int) []int {","canonical_solution":"\treturn append(a, b...)\n}\nfunc ConcatFloat64(a,b []float64) []float64 {\n\treturn append(a, b...)\n}\nfunc ConcatBool(a,b []bool) []bool {\n\treturn append(a, b...)\n}\nfunc ConcatStrings(a,b []string) []string {\n\treturn append(a, b...)\n}","entry_point":"Concat","test":"ConcatStrings([]string{\"a\", \"b\", \"c\"}, []string{\"d\", \"e\"}) // [a b c d e]"}
{"task_id":"task/34","prompt":"import \"math\"\n\nfunc Rads(d float64) float64 {","canonical_solution":"\treturn d * math.Pi / 180.0\n}","entry_point":"Rads","test":"Rads(90.0) // ~1.5708"}
{"task_id":"task/35","prompt":"func FindLastIndexInt(arr []int, f func(int) bool) int {","canonical_solution":"\tfor i := len(arr) - 1; i >= 0; i-- {\n\t\tif f(arr[i]) {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\nfunc FindLastIndexFloat64(arr []float64, f func(float64) bool) int {\n\tfor i := len(arr) - 1; i >= 0; i-- {\n\t\tif f(arr[i]) {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\nfunc FindLastIndexBool(arr []bool, f func(bool) bool) int {\n\tfor i := len(arr) - 1; i >= 0; i-- {\n\t\tif f(arr[i]) {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\nfunc FindLastIndexString(arr []string, f func(string) bool) int {\n\tfor i := len(arr) - 1; i >= 0; i-- {\n\t\tif f(arr[i]) {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}","entry_point":"FindLastIndex","test":"FindLastIndexInt([]int{1, 1, 2}, func(x int) bool { return x%2 == 0 }) // 2\nFindLastIndexFloat64([]float64{4.0, 6.0}, func(x float64) bool { return x%2.0 == 1.0 }) // -1"}
{"task_id":"task/36","prompt":"import \"strings\"\n\nfunc Mask(cc string, n int, m rune) string {","canonical_solution":"\treturn strings.Repeat(string(m), len(cc)-n) + cc[len(cc)-n:]\n}","entry_point":"Mask","test":"Mask(\"1234567890\", 4, '*') // \"******7890\""}
{"task_id":"task/37","prompt":"import \"reflect\"\n\nfunc XProduct(params ...interface{}) [][]interface{} {","canonical_solution":"\ta, b := reflect.ValueOf(params[0]), reflect.ValueOf(params[1])\n\tl := a.Len() * b.Len()\n\tr := make([][]interface{}, l)\n\n\tfor i := 0; i < l; i++ {\n\t\tr[i] = []interface{}{\n\t\t\ta.Index(i % a.Len()).Interface(),\n\t\t\tb.Index((i / a.Len()) % b.Len()).Interface(),\n\t\t}\n\t}\n\treturn r\n\n}","entry_point":"XProduct","test":"XProduct([]int{1, 2}, []string{\"a\", \"b\"}) // [[1 a] [2 a] [1 b] [2 b]]"}
{"task_id":"task/38","prompt":"import \"strings\"\n\nfunc IsUpper(s string) bool {","canonical_solution":"\treturn strings.ToUpper(s) == s\n}","entry_point":"IsUpper","test":"IsUpper(\"GO\") // true\nIsUpper(\"Go\") // false"}
{"task_id":"task/39","prompt":"func NoneInt(arr []int, fn func(int) bool) bool {","canonical_solution":"\tfor _, v := range arr {\n\t\tif fn(v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\nfunc NoneFloat64(arr []float64, fn func(float64) bool) bool {\n\tfor _, v := range arr {\n\t\tif fn(v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\nfunc NoneBool(arr []bool, fn func(bool) bool) bool {\n\tfor _, v := range arr {\n\t\tif fn(v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\nfunc NoneString(arr []string, fn func(string) bool) bool {\n\tfor _, v := range arr {\n\t\tif fn(v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","entry_point":"None","test":"intCheck := func(x int) bool { return x > 1 }\nNoneInt([]int{0, -1}, intCheck) // true\nfloat64Check := func(x float64) bool { return x > 0.5 }\nNoneFloat64([]float64{0.4, 0.1}, float64Check) // true\nboolCheck := func(x bool) bool { return x }\nNoneBool([]bool{false, false}, boolCheck) // true\nstringCheck := func(x string) bool { return len(x) > 1 }\nNoneString([]string{\"g\", \"h\"}, stringCheck) // true"}
{"task_id":"task/40","prompt":"import \"reflect\"\n\nfunc AllSame(params ...interface{}) bool {","canonical_solution":"\tarr := reflect.ValueOf(params[0])\n\tv := arr.Index(0).Interface()\n\n\tfor i := 0; i < arr.Len(); i++ {\n\t\tif arr.Index(i).Interface() != v {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","entry_point":"AllSame","test":"AllSame([]int{1, 2, 3, 4, 5, 6}) // false\nAllSame([]int{1, 1, 1, 1}) // true"}
{"task_id":"task/41","prompt":"import (","canonical_solution":"\t\"fmt\"\n\t\"strings\"\n)\n\nfunc \u0397ammingDistance(n, m int) int {\n\treturn strings.Count(fmt.Sprintf(\"%b\", n^m), \"1\")\n}","entry_point":"HammingDistance","test":"\u0397ammingDistance(2, 3) // 1"}
{"task_id":"task/42","prompt":"import \"reflect\"\n\nfunc Compact(params ...interface{}) []reflect.Value {","canonical_solution":"\tarr := reflect.ValueOf(params[0])\n\tr := make([]reflect.Value, 0)\n\n\tfor i := 0; i < arr.Len(); i++ {\n\t\tif !arr.Index(i).IsZero() {\n\t\t\tr = append(r, arr.Index(i))\n\t\t}\n\t}\n\treturn r\n}","entry_point":"Compact","test":"arr := []float64{1, 0, 5, 2}\narc := make([]float64, 0)\nfor _, v := range Compact(arr) {\n  arc = append(arc, v.Float())\n}\n// arc = [1 5 2]"}
{"task_id":"task/43","prompt":"func IsEven(n int) bool {","canonical_solution":"\treturn n % 2 == 0\n}","entry_point":"IsEven","test":"IsEven(3) // false"}
{"task_id":"task/44","prompt":"import \"fmt\"\n\nfunc FindLastInt(arr []int, f func(int) bool) (int, error) {","canonical_solution":"\tfor i := len(arr) - 1; i >= 0; i-- {\n\t\tif f(arr[i]) {\n\t\t\treturn arr[i], nil\n\t\t}\n\t}\n\treturn 0, fmt.Errorf(\"No matches found\")\n}\nfunc FindLastFloat64(arr []float64, f func(float64) bool) (float64, error) {\n\tfor i := len(arr) - 1; i >= 0; i-- {\n\t\tif f(arr[i]) {\n\t\t\treturn arr[i], nil\n\t\t}\n\t}\n\treturn 0.0, fmt.Errorf(\"No matches found\")\n}\nfunc FindLastBool(arr []bool, f func(bool) bool) (bool, error) {\n\tfor i := len(arr) - 1; i >= 0; i-- {\n\t\tif f(arr[i]) {\n\t\t\treturn arr[i], nil\n\t\t}\n\t}\n\treturn false, fmt.Errorf(\"No matches found\")\n}\nfunc FindLastString(arr []string, f func(string) bool) (string, error) {\n\tfor i := len(arr) - 1; i >= 0; i-- {\n\t\tif f(arr[i]) {\n\t\t\treturn arr[i], nil\n\t\t}\n\t}\n\treturn \"\", fmt.Errorf(\"No matches found\")\n}","entry_point":"FindLast","test":"FindLastInt([]int{1, 1, 2}, func(x int) bool { return x%2 == 0 }) // 2 nil\nFindLastFloat64([]float64{4.0, 6.0}, func(x float64) bool { return x%2.0 == 1.0 }) // 0.0 \"No matches found\""}
{"task_id":"task/45","prompt":"func FindIndexInt(arr []int, f func(int) bool) int {","canonical_solution":"\tfor i, v := range arr {\n\t\tif f(v) {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\nfunc FindIndexFloat64(arr []float64, f func(float64) bool) int {\n\tfor i, v := range arr {\n\t\tif f(v) {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\nfunc FindIndexBool(arr []bool, f func(bool) bool) int {\n\tfor i, v := range arr {\n\t\tif f(v) {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\nfunc FindIndexString(arr []string, f func(string) bool) int {\n\tfor i, v := range arr {\n\t\tif f(v) {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}","entry_point":"FindIndex","test":"FindIndexInt([]int{1, 1, 2}, func(x int) bool { return x%2 == 0 }) // 2\nFindIndexFloat64([]float64{4.0, 6.0}, func(x float64) bool { return x%2.0 == 1.0 }) // -1"}
{"task_id":"task/46","prompt":"func FahrenheitToCelsius(d float64) float64 {","canonical_solution":"\treturn (d - 32.0) * 5.0 / 9.0\n}","entry_point":"FahrenheitToCelsius","test":"FahrenheitToCelsius(32.0) // 0.0"}
{"task_id":"task/47","prompt":"import (","canonical_solution":"\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n)\n\nfunc Join(params ...interface{}) string {\n\tarr, sp := reflect.ValueOf(params[0]),\n\t\treflect.ValueOf(params[1]).String()\n\tars := make([]string, arr.Len())\n\n\tfor i := 0; i < arr.Len(); i++ {\n\t\tars[i] = fmt.Sprintf(\"%v\", arr.Index(i))\n\t}\n\n\treturn strings.Join(ars, sp)\n\n}","entry_point":"Join","test":"Join([]int{1, 2, 3}, \".\") // \"1.2.3\""}
{"task_id":"task/48","prompt":"func IsOdd(n int) bool {","canonical_solution":"\treturn n % 2 == 1\n}","entry_point":"IsOdd","test":"IsOdd(3) // true"}
{"task_id":"task/49","prompt":"func AllInt(arr []int, fn func(int) bool) bool {","canonical_solution":"\tfor _, v := range arr {\n\t\tif !fn(v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\nfunc AllFloat64(arr []float64, fn func(float64) bool) bool {\n\tfor _, v := range arr {\n\t\tif !fn(v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\nfunc AllBool(arr []bool, fn func(bool) bool) bool {\n\tfor _, v := range arr {\n\t\tif !fn(v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\nfunc AllString(arr []string, fn func(string) bool) bool {\n\tfor _, v := range arr {\n\t\tif !fn(v) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","entry_point":"All","test":"intCheck := func(x int) bool { return x > 1 }\nAllInt([]int{4, 2}, intCheck) // true\nfloat64Check := func(x float64) bool { return x > 0.5 }\nAllFloat64([]float64{0.8, 1.0}, float64Check) // true\nboolCheck := func(x bool) bool { return x }\nAllBool([]bool{true, true}, boolCheck) // true\nstringCheck := func(x string) bool { return len(x) > 1 }\nAllString([]string{\"go\", \"hi\"}, stringCheck) // true"}
{"task_id":"task/50","prompt":"import \"math\"\n\nfunc MinOf(nums ...float64) float64 {","canonical_solution":"\tmin := math.Inf(1)\n\tfor _, num := range nums {\n\t\tmin = math.Min(num, min)\n\t}\n\treturn min\n}","entry_point":"MinOf","test":"MinOf(3.0, 1.0, 2.0) // 1.0"}
{"task_id":"task/51","prompt":"import \"reflect\"\n\nfunc Includes(params ...interface{}) bool {","canonical_solution":"\tarr, v := reflect.ValueOf(params[0]),\n\t\treflect.ValueOf(params[1]).Interface()\n\n\tfor i := 0; i < arr.Len(); i++ {\n\t\tif arr.Index(i).Interface() == v {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}","entry_point":"Includes","test":"MySnippet() // \"result\""}
{"task_id":"task/52","prompt":"func CelsiusToFahrenheit(d float64) float64 {","canonical_solution":"\treturn 1.8 * d + 32.0\n}","entry_point":"CelsiusToFahrenheit","test":"CelsiusToFahrenheit(33.0) // 91.4"}
{"task_id":"task/53","prompt":"import \"math\"\n\nfunc Degrees(r float64) float64 {","canonical_solution":"\treturn r * 180.0 / math.Pi\n}","entry_point":"Degrees","test":"Degrees(math.Pi / 2.0) // 90.0"}
{"task_id":"task/54","prompt":"import \"strings\"\n\nfunc IsPalindrome(s string) bool {","canonical_solution":"\tv := strings.ToLower(strings.Join(strings.Fields(s), \"\"))\n\tfor i := range v {\n\t\tif v[len(v)-i-1] != v[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}","entry_point":"IsPalindrome","test":"IsPalindrome(\"taco cat\") // true"}
{"task_id":"task/55","prompt":"import \"strings\"\n\nfunc Decapitalize(s string) string {","canonical_solution":"\treturn strings.ToLower(s[0:1]) + s[1:]\n}","entry_point":"Decapitalize","test":"Decapitalize(\"Boomerang\") // \"boomerang\""}
{"task_id":"task/56","prompt":"func MapNumRange(num, iMin, iMax, oMin, oMax float64) float64 {","canonical_solution":"\treturn ((num-iMin)*(oMax-oMin))/(iMax-iMin) + oMin\n}","entry_point":"MapNumRange","test":"MapNumRange(5.0, 0.0, 10.0, 0.0, 100.0) // 50.0"}
{"task_id":"task/57","prompt":"import \"fmt\"\n\nfunc Stringify(v interface{}) string {","canonical_solution":"\treturn fmt.Sprintf(\"%v\", v)\n}","entry_point":"Stringify","test":"Stringify(90) // \"90\"\nStringify(2.0) // \"2.0\"\nStringify(true) // \"true\""}
{"task_id":"task/58","prompt":"import \"math\"\n\nfunc MaxOf(nums ...float64) float64 {","canonical_solution":"\tmax := math.Inf(-1)\n\tfor _, num := range nums {\n\t\tmax = math.Max(num, max)\n\t}\n\treturn max\n}","entry_point":"MaxOf","test":"MaxOf(3.0, 4.0, 2.0) // 4.0"}
{"task_id":"task/59","prompt":"func gcd(x, y int) int {","canonical_solution":"\tif y == 0 {\n\t\treturn x\n\t}\n\treturn gcd(y, x%y)\n}\n\nfunc GCD(nums ...int) int {\n\tr := nums[0]\n\tfor _, num := range nums[1:] {\n\t\tr = gcd(r, num)\n\t}\n\treturn r\n}","entry_point":"GCD","test":"GCD(8, 36) // 4\nGCD([]int{12, 8, 32}...) // 4"}
{"task_id":"task/60","prompt":"func DedupeInts(arr []int) []int {","canonical_solution":"\tm, uniq := make(map[int]bool), make([]int, 0)\n\tfor _, v := range arr {\n\t\tif _, ok := m[v]; !ok {\n\t\t\tm[v], uniq = true, append(uniq, v)\n\t\t}\n\t}\n\treturn uniq\n}\nfunc DedupeFloat64s(arr []float64) []float64 {\n\tm, uniq := make(map[float64]bool), make([]float64, 0)\n\tfor _, v := range arr {\n\t\tif _, ok := m[v]; !ok {\n\t\t\tm[v], uniq = true, append(uniq, v)\n\t\t}\n\t}\n\treturn uniq\n}\nfunc DedupeStrings(arr []string) []string {\n\tm, uniq := make(map[string]bool), make([]string, 0)\n\tfor _, v := range arr {\n\t\tif _, ok := m[v]; !ok {\n\t\t\tm[v], uniq = true, append(uniq, v)\n\t\t}\n\t}\n\treturn uniq\n}","entry_point":"Dedupe","test":"DedupeInts([]int{1, 2, 1, 2, 3, 3, 4}) // [1 2 3 4]"}
